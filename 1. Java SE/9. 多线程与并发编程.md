# 九. 并发

## 9.1 什么是线程

多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。通常，每一个任务称为一个**线程(thread)**，它是线程控制的简称。可以同时运行一个以上线程的程序称为**多线程程序(multithreaded)**。

### 9.1.1 使用线程给其他任务提供机会

下面是在一个单独的线程中执行一个任务的简单过程：

1. 将任务代码移到实现了 Runnable 接口的类的 *run* 方法中。这个接口非常简单，只有一个方法：

```java
public interface Runnale {
    void run();
}
```

由于 Runnbale 是一个函数式接口，可以用 lambda 表达式建立一个实例：

```java
Runnable r = () -> { ... };
```

2. 由 Runnble 创建一个 Thread 对象：

```java
Thread t = new Thread(r);
```

3. 启动线程：

```java
t.start();
```

或者也可以通过构建一个 Thread 类的子类定义一个线程，如下所示：

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        ...
    }
}
```

然后，构造一个子类对象，并调用 *start* 方法。不过，这种方法已经不再推荐。应该将要并行运行的任务与运行机制解耦合。如果有很多任务，要为每个任务创建一个独立的线程所付出的代价太大了。可以使用线程池来解决这个问题。

**不要调用 Thread 类或者 Runnable 对象的 *run* 方法。直接调用 *run* 方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用 *Thread.start* 方法。这个方法将创建一个执行 *run* 方法的新线程。**



## 9.2 中断线程

当线程的 *run* 方法执行方法体中的最后一条语句后，并经由执行 *return* 语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止。在 Java 早起版本中，还有一个 *stop* 方法，其他线程可以调用它终止线程。但是，这个方法现在已经被弃用了。

没有可以强制线程终止的方法。但是，*interrupt* 方法可以用来请求终止线程。

当对一个线程调用 *interrupt* 方法时，线程**中断状态**将被置位。这是每一个线程都具有的 boolean 标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断，

要想弄清楚中断状态是否被置位，首先调用静态的 *Thread.currentThread* 方法获得当前线程，然后调用 *isInterrupted* 方法：

```java
while (!Thread.currentThread().isInterrupted() && ...) {
    ...
}
```

但是如果线程被阻塞，就无法检测中断状态。这是产生 InterruptedException 异常的地方。当在一个被阻塞的线程上调用 *interrupt* 方法，阻塞调用将会被 Interrupted Exception 异常中断。(存在不能被中断的阻塞式 I/O 调用，应考考虑选择可中断的调用)。

没有任何语言方面的需要要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后，继续执行，而不理会中断。但是，更普遍的情况是，线程将简单地将中断作为一个终止的请求。这种线程 *run* 方法具有如下形式：

```java
Runnable r = () -> {
    try {
        ...
        while (!Thread.currentThread().isInterrupted() && ...) {
            ...
        }    
    } catch (InterruptedException) {
        // thread was interrupted during sleep or wait
    } finally {
        // clean up if required
    }
    // exiting the run method terminates the thread
};
```

如果在每次工作迭代这时候调用 *sleep* 方法，*isInterrupted* 检测既没有必要也没有用处。如果在中断状态被置位时调用 *sleep* 方法，它不会休眠。相反，它将清楚这一状态并抛出 InterruptedException。因此，如果你的循环调用 *sleep*，不会检测中断状态。相反，要如下所示捕获 InterruptedException：

```java
Runnable r = () -> {
    try {
        ...
        while (...) {
            ...
            Thread.sleep(DELAY);    
        }
    } catch (InterruptedException) {
        // thread was interrupted during sleep
    } finally {
        // clean up if required
    }
    // exiting the run method terminates the thread
}
```



## 9.3 线程状态

线程可以有如下 6 种状态：

- New(新创建)
- Runnable(可运行)
- Blocked(被阻塞)
- Waiting(等待)
- Timed Waiting(计时等待)
- Terminated(被终止)

### 9.3.1 新创建线程

当用 new 关键字创建一个新线程时，如 `new Thread(r)`，该线程还没开始运行。这意味着它的状态是 new。当一个线程处于创建状态时，程序还没有开始运行线程中的代码。在线程运行之前还有一些基础工作要做。



### 9.3.2 可运行线程

一旦调用 *start* 方法，线程处于 runnable 状态。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。(Java 的规范说明没有将它作为一个单独状态。一个正在运行中的线程仍然处于可运行状态。)

一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统**剥夺**该线程的运行权，并给另一个线程运行机会。当选择下一个线程时，操作系统考虑线程的**优先级**。

现在所有的桌面以及服务器操作系统都使用抢占式调度。但是，像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只要调用 *yield* 方法、或者被阻塞或等待时，线程才失去控制权。

当具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理器的数目，调度器依然采用时间片机制。

记住，在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行。



### 9.3.3 被阻塞线程和等待线程

当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少得资源。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的。

- 当一个线程试图获取一个内部的**对象锁**，而该锁被其他线程持有，则该线程进入**阻塞状态**。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。
- 当线程等待另一个线程通知调度器一个条件时，它自己进入**等待状态**。实际上，被阻塞状态与等待状态是有很大不同的。
- 有几个方法有一个超时参数。调用它们导致线程进入**计时等待(timed waiting)**状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有 `Thread.sleep` 和 `Object.wait`、`Thread.join`、`Lock.tryLock` 以及 `Condition.await` 的计时版。



### 9.3.4 被终止的线程

线程因如下两个原因之一而被终止：

- 因为 *run* 方法正常退出而自然死亡。
- 因为一个没有捕获的异常终止了 *run* 方法而意外死亡。

特别是，可以调用线程的 *stop* 方法杀死一个线程。该方法抛出 ThreadDeath 错误对象，由此杀死线程。但是，*stop* 方法已过时，不要在自己的代码中调用这个方法。

![image-20220706095022725](asset/image/image-20220706095022725.png)

*java.lang.Thread*：

```java
void join();  // 等待终止指定的线程
void join(long millis);  // 等待指定的线程死亡或者经过指定的毫秒数
Thread.State getState();  // 得到线程的状态
void stop();  // 停止该线程。这一方法已经过时
void suspend();  // 暂停这一线程的执行。这一方法已经过时
void resume();  // 恢复线程。这一方法仅仅在调用 suspend() 方法之后调用。这一方法已经过时
```



## 9.4 线程属性

### 9.4.1 线程优先级

在 Java 程序设计语言中，每一个线程有一个**优先级**。默认情况下，一个线程继承它的父线程的优先级。可以用 *setPriority* 方法提高或降低任何一个线程的优先级。可以将优先级设置为 MIN_PRIORITY(在 Thread 类中定义为 1)与 MAX_PRIORITY(定义为 10)之间的任何值。NORM_PRIORITY 被定义为 5.

每当线程调度器有机会选择线程时，它首先选择具有较高优先级的线程。但是，线程优先级是**高度依赖于系统的**。当虚拟机依赖于宿主机平台的线程实现机制时，Java 线程的优先级被映射到宿主机平台的优先级上，优先级个数也许更多，也许更少。

例如，Winodws 有 7 哥优先级别。一些 Java 优先级将映射到相同的操作系统优先级。在 Oracle 为 Linux 提供的 Java 虚拟机中，线程的优先级被忽略——所有线程具有相同的优先级。



### 9.4.2 守护线程

可以通过调用：

```java
t.setDaemon(true);
```

将线程转换为**守护线程(daemon thread)**。这样一个线程没有什么神奇。守护线程的唯一用途是为其他线程提供服务。计时线程就是一个例子，它定时地发送“计时器嘀嗒”信号给其他线程或清空过时的高速缓存项的线程。当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没必要继续运行程序了。

守护线程有时会被初学者错误地使用，他们不打算考虑关机(shutdown)动作。但是，这是很危险的。守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。



### 9.4.3 未捕获异常处理器

**线程的 *run* 方法不能抛出任何受查异常**，但是，非受查异常会导致线程终止。在这种情况下，线程就死亡了。

但是不需要任何 catch 子句来处理可以被传递的异常。相反，就在线程死亡之前，异常被传递到一个用于为捕捉异常的处理器。

该处理器必须属于一个实现 `Thread.UncaughtExceptionHandler` 接口的类。这个接口只有一个方法。

```java
void uncaughtException(Thread t, Throwable e);
```

可以用 *setUncaughrtExceptionHandler* 方法为任何线程安装一个处理器。也可以用 Thread 类的静态方法 *setDefaultUncaughtExceptionHandler* 为所有线程安装一个默认的处理器。替换处理器的可以使用日志 API 发送未捕获异常的报告到日志文件。

如果不安装默认的处理器，默认的处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的 ThreadGroup 对象。

ThreadGroup 类实现了 Thread.UncaughtExceptionHandler 接口。它的 uncaughtException 方法做如下操作：

1. 如果该线程组有父线程组，那么父线程组的 *uncaughtException* 方法被调用。
2. 否则，如果 *Thread.getDefaultExceptionHandler* 方法返回一个非空的处理器，则调用该处理器。
3. 否则，如果 Throwable 是 ThreadDeath 的实例，什么都不做。
4. 否则，线程的名字以及 Throwable 的栈轨迹被输出到 System.err 上。



## 9.5 同步

在大多数实际的多线程应用中，两个或两个以上的线程需要共享对同一数据的读取。如果两个线程存取相同的对象，并且每一个线程都调用了一个修改改对象状态的方法，将会发生什么呢？可以想象，线程彼此踩了对象的脚。根据各线程访问数据的次序，可能会产生错误的对象。这样一个情况通常称为**竞争条件(race condition)**。

### 9.5.1 竞争条件的一个例子

为了避免多线程引起的对共享数据的讹误，必须学习如何**同步存取**。

下面案例模拟一个有若干账户的银行。随机地生成在这些账户之间转移欠款的交易。每一个账户有一个线程。每一笔交易中，会从线程所服务的账户中随机转移一定数目的钱款到另一个随机账户。

定义一个 *transfer* 方法，这个方法从一个账户转移一定数量的钱款到另一个随机账户。

```java
public void transfer(int from, int to, double amount) {
    if (accounts[from] < amount) {
        return;
    }
    System.out.print(Thread.currentThread());
    accounts[from] -= amount;
    System.out.printf(" %10.2f from %d to %d", amount, from, to);
    accounts[to] += amount;
    System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
}
```

Bank 类：

```java
public class Bank {
    private final double[] accounts;

    public Bank(int n, double initialBalance) {
        accounts = new double[n];
        Arrays.fill(accounts, initialBalance);
    }

    public void transfer(int from, int to, double amount) {
        if (accounts[from] < amount) { 
            return;
        }
        System.out.print(Thread.currentThread());
        accounts[from] -= amount;
        System.out.printf(" %10.2f from %d to %d", amount, from, to);
        accounts[to] += amount;
        System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
    }

    public double getTotalBalance() {
        return Arrays.stream(accounts).reduce(0, Double::sum);
    }

    public int size() {
        return accounts.length;
    }
}
```

这是 Runnable 接口的实现代码，它的 *run* 方法不断地从一个固定的银行账户取出钱款。在每一次迭代中，*run* 方法随机选择一个目标账户和一个随机账户，调用 bank 对象的 *transfer* 方法，然后睡眠：

```java
public class BankTest {
    public static final int NACCOUNTS = 100;
    public static final double INITIAL_BALANCE = 1000;
    public static final double MAX_AMOUNT = 1000;
    public static final int DELAY = 10;

    public static void main(String[] args) {
        Bank bank = new Bank(NACCOUNTS, INITIAL_BALANCE);
        for (int i = 0; i < NACCOUNTS; i++) {
            int fromAccount = i;
            Runnable r = () -> {
                try {
                    while (true) {
                        int toAccount = (int) (bank.size() * Math.random());
                        double amount = MAX_AMOUNT * Math.random();
                        bank.transfer(fromAccount, toAccount, amount);
                        Thread.sleep((int) (DELAY * Math.random()));
                    }
                } catch (InterruptedException e) {
                }
            };
            Thread t = new Thread(r);
            t.start();
        }
    }
}
```



当这个模拟程序运行时，不清楚在某一时刻某一银行账户中有多少钱。但是，知道所有账户的总金额应该保持不变，因为所做的一切不过是从一个账户转移钱款到另一个账户。

在每一次交易的结尾，*transfer* 方法重新计算总值并打印出来。

显然这里面出现了错误，在最初的交易中，银行的余额保持 100,000，但是到后面余额就会发生了变化，这也就是所谓的线程安全问题。



### 9.5.2 竞争条件详解

程序运行一段时间后，错误不知不觉就出现了，总额要么增加，要么就减少。当两个线程试图同时更新同一个账户的时候，这个问题就出现了。假定两个线程同时执行指令：

```java
accounts[to] += amount;
```

问题就在于这不是原子操作。该指令可能被处理如下：

1. 将 accounts[to] 加载到寄存器。
2. 增加 amount。
3. 将结果写回 accounts[to]。

现在，假定第 1 个线程执行步骤 1 和 2，然后，它被剥夺了运行权。假定第 2 个线程被唤醒并修改了 accounts 数组中的同一项。然后，第 1 个线程被唤醒完成其第 3 步。

这样，这一动作擦去了第二个线程所做的更新。于是，总金额不再正确。

![image-20220706150118880](asset/image/image-20220706150118880.png)



### 9.5.3 锁对象

有两种机制防止代码块受到并发访问的干扰。Java 语言提供一个关键字达到这一目的，并且 Java 5 引入了 ReentrantLock 类。synchronized 关键字自动提供一个锁以及相关的“条件”，对于大多数需要显示锁的情况，这是很便利的。*java.util.concurrent* 包为这些基础

使用 ReentrantLock 保护代码块的基本结构如下：

```java
myLock.lock();  // a ReentrantLock object
try {
    ...
} finall {
    myLock.unlock();  // make sure the lock is unlocked even if an exception is thrown
}
```

这一结构确保任何时刻只有一个线程进入临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过 lock 语句。当其他线程调用 *lock* 时，它们被阻塞，直到第一个线程释放锁对象。

**把解锁操作放在 finally 子句中是至关重要的。如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞。如果使用锁，就不能使用带资源的 try 语句。首先，解锁方法名不是 *close*。不过，即使将它重命名，带资源的 try 语句也无法正常工作。它的首部希望声明一个新变量。但是如果使用一个锁，你可能想使用多个线程共享的那个变量(而不是新变量)。**

e.g. 使用一个锁保护 Bank 类的 *transfer* 方法：

```java
public class Bank {
	private Lock bankLock = new ReentrantLock();
    ...
        
    public void transfer(int from, int to, double amount) throws InterruptedException {
        bankLock.lock();
        try {
            while (accounts[from] < amount)
                sufficientFunds.await();
            System.out.print(Thread.currentThread());
            accounts[from] -= amount;
            System.out.printf(" %10.2f from %d to %d", amount, from, to);
            accounts[to] += amount;
            System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
            sufficientFunds.signalAll();
        } finally {
            bankLock.unlock();
        }
    }    
}
```

假定一个线程调用 *transfer*，在执行结束前被剥夺了运行权。假定第二个线程也调用 transfer，由于第二个线程不能获得锁，将在调用 *lock* 方法时被阻塞。它必须等待第一个线程完成 *transfer* 方法的执行之后才能再度被激活。当第一个线程释放锁时，那么第二个线程才能开始运行。

![image-20220706153806075](asset/image/image-20220706153806075.png)

简单来讲，所谓同步，也就是逻辑上的串行化执行。

锁是**可重入的**，因为线程可以重复地获得已经持有的锁。锁保持一个**持有计数(hold count)**来跟踪对 lock 方法的嵌套调用。线程在每一次调用 *lock* 都要调用 *unlock* 来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。

通常，可能想要保护若干个操作来更新或检查共享对象的代码块。要确定这些操作完成后，另一个线程才能使用相同对象。要留心临界区的代码，不要因为异常的抛出而跳出临界区。如果在临界区代码结束之前抛出了异常，finally 子句将释放锁，但会使对象可能处于一种受损状态。



### 9.5.4 条件对象

通常，线程进入临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。

一个锁对象可以有一个或多个相关的条件对象。可以使用 *newCondition* 方法获得一个条件对象。习惯上给每一个条件对象命名为可以反映它们所表达的条件的名字。例如，在此设置一个“余额充足”条件。

```java
public class Bank {
    priavte Condition sufficientFunds;
    ...
    public Bank() {
        ...
        sufficientFunds = bankLock.newCondition();    
    }            
}
```

如果 *transfer* 方法发现余额不足，它调用：

```java
sufficientFunds.await();
```

**当前线程现在被阻塞了，并放弃了锁。**我们希望这样可以使得另一个线程可以进行增加账户余额的操作。等到获得锁的线程的调用 *await* 方法的线程存在本质上的不同。一旦一个线程调用 *await* 方法，它进入该条件的等待集。当锁可用时，该线程不能马上解除阻塞。相反，它处于阻塞状态，直到另一个线程调用统一条件上的 *signalAll* 方法时为止。

当另一个线程转账时，它应该调用：

```java
sufficientFunds.signalAll();
```

这一调用重新激活因为这一条件而等待的所有线程。当这些线程从等待集当中移出时，它们再次成为可运行的，调度器再次激活它们。同时，它们将试图重新进入该对象。一旦锁成为可用的，它们中的某个将从 *await* 返回调用，获得该锁并从被阻塞的地方**继续**执行。

此时，线程应该再次测试该条件。由于无法确保该条件被满足——*signalAll* 方法仅仅是通知正在等待的线程：此时有可能已经满足条件，值得再次去检测该条件。

通常，对 *await* 的调用应该在如下形式的循环体中：

```java
while (!(ok to proceed)) {
    condition.await();
}
```



至关重要的是最终需要某个其他线程调用 *signalAll* 方法。当一个线程调用 *await* 时，它没有办法重新激活自身。它寄希望于其他线程。如果没有其他线程来重新激活等待的线程，它就永远不再运行了。这将导致令人不愉快的**死锁(deadlock)**现象。如果所有其他线程被阻塞，最后一个活动线程在解除其他线程的阻塞状态之前就调用 *await* 方法，那么它也被阻塞。没有任何线程可以解除其他线程的阻塞，那么该程序就挂起了。

应该何时调用 *signalAll* 方法？经验上讲，在对象的状态有利于等待线程的方向改变时调用 *signalAll*。例如，当一个账户余额发生改变时，等待的线程会应该有机会检查余额。在例子中，当完成了住转账时，调用 *signalAll* 方法：

```java
public void transfer(int from, int to, int amount) {
    banLock.lock();
    try {
        while (accounts[from] < amount) {
            sufficientFunds.await();
        }
        // transfer funds
        ...
        sufficientFunds.signalAll();
    }
}
```

注意调用 *signalAll* 不会立即激活一个等待线程。它仅仅解除等待线程的阻塞，以便这些线程退出同步方法后，通过竞争实现对对象的访问。

另一个方法 *signal*，则是随机解除等待集中某个线程的阻塞状态。这比解除所有线程的阻塞更加有效，但也存在危险。如果随机选择的线程发现自己仍然不能运行，那么它再次被阻塞。如果没有其他线程再次调用 *signal*，那么系统就死锁了。

**当一个线程拥有某个条件的锁时，它仅仅可以在该条件上调用 *await*、*signalAll* 或 *signal* 方法。**



### 9.5.5 synchronized关键字



### 9.5.6 同步阻塞



### 9.5.7 监视器概念



### 9.5.8 Volatile域



### 9.5.9 final变量



### 9.5.10 原子性



### 9.5.11 死锁



### 9.5.12 线程局部变量





### 9.5.13 锁测试与超时



### 9.5.14 读写锁



### 9.5.15 为什么抛弃stop和suspend方法











## 9.6 阻塞队列



## 9.7 线程安全的集合



## 9.8 Callable和Future



## 9.9 执行器



## 9.10 同步器

