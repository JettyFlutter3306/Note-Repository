# 六. 泛型程序设计

## 6.1 Why 泛型程序设计

**泛型程序设计(Generic Programming)**意味着编写的代码可以被很多不同类型的对象重用。例如，我们并不希望聚集 String 和 File 对象分别设计不同的类。实际上，也不需要这样做，因为一个 ArrayList 类可以聚集任何类型的对象。这是一个泛型程序设计的实例。

### 6.1.1 类型参数的好处

在 Java 中增加泛型类之前，泛型程序设计是用继承实现的。ArrayList 类只维护一个 Object 引用的数组：

```java
public class ArrayList {
    private Object[] elements;
    ...
    public Object get(int i) {...}
    public void add(Object o) {...}
}
```

这种方法有两个问题。当获取一个值时必须进行强制类型转换。

```java
String fileName = (String) list.get(0);
```

此外这里没有错误检查。可以向数组列表中添加任何类的对象。

```java
list.add(new Person());
```

对于这个调用，编译和运行都不会出错。然而在其他地方，如果将 get 的结果做强制类型转换为 String 类型，救护产生一个错误。

泛型提供了一个更好的解决方案：**类型参数(type parameters)**。ArrayList 类有一个类型参数指示元素的类型：

```java
List<String> list = new ArrayList<>();
```

> 使用 Java SE 7 之后的版本可以使用菱形运算符<>省略后面的类型。编译器可以自动推导类型。

编译器也可以很好地利用这个信息。当调用 get 的时候，不需要进行强制类型转换，编译器就知道返回值是 String，而不是 Object。

```java
String fileName = list.get(0);
```

类型参数的魅力在于：使得程序具有更好的可读性和安全性。



## 6.2 定义简单泛型

一个**泛型类(generic class)**就是具有一个或多个类型变量的类。

e.g. 声明一个泛型类：

```java
public class Pair<T> {
    private T first;
    private T second;
    public Pair() {}
    public Pair(T first, T second) {
        this.first = first;
        this.second = second;
    }
    public T getFirst() {
        return first;
    }
    public T getSecond() {
        return second;
    }
    public void setFirst(T newValue) {
        first = newValue;
    }
    public void setSecond(T newValue) {
        second = newValue;
    }
}
```

Pair 类引入了一个类型变量 T，使用尖括号\<\>括起来，并放在类名的后面。泛型类可以有多个类型变量。

e.g. 定义有两个类型参数的 Pair 类：

```java
public class Pair<T, U> {
    ...
}
```

类型变量使用大写形式，且比较短，这是很常见的。在 Java 库中，使用变量 E 表示集合的元素类型，K 和 V 分别表示哈希表的关键字和值的类型。T 表示任意类型。

e.g. 实例化一个 Pair 泛型类对象：

```java
Pair<String> pair = new Pair<>();
```

简而言之，泛型类可以看作普通类的工厂。



## 6.3 泛型方法

在 Java 中不仅有泛型类，而且还有泛型方法，定义泛型方法这样也就不需要使用泛型类的类型参数了，或者直接不需要定义泛型类。

e.g. 定义一个泛型方法：

```java
public class IArrays {
    public static <T> T getMiddle(T... a) {
    	return a[a.length / 2];
	}
}
```

这个方法是在普通类中定义的，而不是在泛型类中定义的。然而，这是一个泛型方法，可以从尖括号和类型变量看出这一点。**注意，类型变量放在修饰符的后面，返回类型的前面。**

泛型方法可以在定义在普通类中，也可以定义在泛型类中。



## 6.4 类型变量的限定

有时候，类或方法需要对类型变量加以约束。下面是一个典型的例子，计算数组中的最小元素：

```java
public class TestArray {
	public static <T> T min(T[] a) {
        if (a == null || a.length) {
            return null;
        }
        T smallest = a[0];
        for (int i = 1; i < a.length; i++) {
            if (smallest.compareTo(a[i]) > 0) {
                smallest = a[i];
            }
        }
        return smallest;
    }
}
```

但是这里有一个问题，smallest 是一个类型为 T 的对象，也就是说它可以是任意一个对象。如何确定它实现了 Comparable 接口呢？

解决方案就是将 T 限制为实现了 Comparable 接口的类。可以通过对类型变量 T 设置**限定(bound)**实现这一点：

```java
public static <T extends Comparable> T min(T[] a) { ... }
```

实际上 Comparable 接口本身就是一个泛型类型。泛型的 min 方法只能被实现了 Comparable 接口的类的数组调用。

也许你或许会感到奇怪，为什么要使用关键字 `extends` 而不是使用 `implements` ？毕竟，Comparable 是一个接口。下面的记法：

```java
<T extends BoundingType>
```

表示 T 应该是绑定类型的**子类型(subtype)**。T 和绑定类型可以是类，也可以是接口。选择关键字 `extends` 原因是更接近子类的概念，并且 Java 的设计者也不打算在语言中再添加一个新的关键字。

一个类型变量或通配符可以有多个限定：

```java
T extends Comparable & Serializable
```

限定符使用 `&` 分隔，而逗号用来分隔类型变量。

在 Java 的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个。



## 6.5 泛型代码与虚拟机

虚拟机没有泛型类型对象——所有对象都属于普通类。在泛型实现的早期版本中，甚至能够将使用泛型的程序编译为在 1.0 虚拟机上运行的类文件。这个向后兼容性在 Java 泛型开发的后期被放弃了。

### 6.5.1 类型擦除

无论何时定义一个泛型类型，都自动提供了一个相应的**原始类型(raw type)**。原始类型的名字就是删去类型参数后的泛型类型名。**擦除(erased)**类型变量，并替换为限定类型(无限定类型的变量用 Object)。

e.g. Pair 类的原始类型：

```java
public class Pair {
    private Object first;
    private Object second;
    public Pair(Object first, Object second) {
        this.first = first;
        this.second = second;
    }
    public Object getFirst() {
        return first;
    }
    public Object getSecond() {
        return second;
    }
    public void setFirst(Object newValue) {
        first = newValue;
    }
    public void setSecond(Object newValue) {
        second = newValue;
    }
}
```

因为 T 是一个无限定的变量，所以直接用 Object 替换。

结果是一个普通的类，就好像泛型引入了 Java 语言之前已经实现的那样。

在程序中可以包含不同类型的 Pair，例如，Pair\<String\> 或 Pair\<LocalDate\>。而擦除类型后就变成原始的 Pair 类型了。

原始类型用第一个限定的类型变量来替换，如果没有给定限定那就用 Object 替换。例如，Pair\<T\> 中的类型变量没有显示的限定，因此，原始类型用 Object 替换 T。假设声明了一个不同的类型。

```java
public class Interval<T extends Comparable & Serializable> implements Serializable {
    private T lower;
    private T upper;
    ...
    public Interval(T first, T second) {
        if (first.compareTo(second) < 0) {
            lower = first;
            upper = second;
        } else {
            lower = second;
            upper = first;
        }
    }    
}
```

原始类型 Interval 如下所示：

```java
public class Interval implements Serializable {
    private Comparable lower;
    private Comparable upper;
    ...
    public Interval(Comparable first, Comparable second) { ... }    
}
```

你肯定想知道切换限定：class Interval\<T extends Serializable & Comparable\> 会发生什么。如果这样做，原始类型用 Serializable 替换 T，而编译器在必要时要向 Comparable 插入强制类型转换。为了提高效率，应该将标签(tagging)接口(即没有方法的接口)放在边界列表的末尾。



### 6.5.2 翻译泛型表达式

当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。例如，下面这两条语句：

```java
Pair<Employee> buddies = ...;
Employee buddy = buddies.getFirst();
```

擦除 *getFirst* 的返回类型后返回 Object 类型。编译器自动插入 Employee 的强制类型转换。也就是说，编译器把这个方法翻译为两条虚拟机指令：

- 对原始方法 Pair.getFirst 的调用。
- 将返回的 Object 类型强制转换为 Employee 类型。

当存取一个泛型域时也要插入强制类型转换。假设 Pair 类的 first 域和 second 域都是公有的表达式：

```java
Employee buddy = buddies.first;
```

也会在结果字节码插入强制类型转换。



### 6.5.3 翻译泛型方法















### 6.5.4 调用遗留代码









## 6.6 约束与局限性



## 6.7 泛型类型的继承规则



## 6.8 通配符类型



## 6.9 反射和泛型