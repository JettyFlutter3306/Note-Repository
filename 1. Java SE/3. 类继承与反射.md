# 三. 继承与反射

这一章主要介绍面向对象程序设计的另外一个基本概念,那就是**继承 (inheritance)**.利用继承,可以基于已存在的类构造一个新类.继承已存在的类就是复用这些类的方法和域.这是 Java 程序设计中的一项核心技术.

本章还介绍了**反射 (reflection)**的概念.反射式值在程序运行期间发现更多的类及其属性的能力.这是一个功能强大的特性,使用起来比较复杂.

## 3.1 类,超类和子类

### 3.1.1 定义子类

使用 `extends` 关键字来继承一个类:

```java
class Creature {
    private int age;
    
    public Creature(int age) {
        this.age = age;
    }
    
	public void eat() {
        
    }    
}

class Person extends Creature {
	
}
```

关键字 `extends` 表明正在构造的新类派生于一个已存在的类.已存在的类称为**超类 (super class)**,**基类 (base class)** 或 **父类 (parent class)**.新类称为**子类 (subclass)**,**派生类 (derived class)** 或 **孩子类 (child class)**.超类和子类是 Java 程序员最常用的两个术语,而了解其他语言的程序员可能更加偏爱使用父类和孩子类,这些都是继承时使用的术语.



### 3.1.2 覆盖方法

超类中的有些方法对子类并不一定适用.具体来说 Person 类继承了 eat 方法,但是那是父类的行为,子类可以对父类进行覆盖,因为人类有人类吃东西的方法.为此,需要提供一个新的方法来**覆盖 (override)**超类中的这个方法,这同时也称为**重写**:

```java
public class Person extends Creature {
	@Override
    public void eat() {
    	System.out.println("用筷子吃饭...");    
    }
}
```

子类不可以直接访问父类的**私有域 **,必须得要使用父类提供的 **getter** 来访问.比如说访问上面的 *age* 属性,得要使用父类提供的 *getAge* 方法才可以访问,没有这个 **getter** 就无法访问,但是子类是**隐式地**拥有这个属性的.

同时,子类也可以在本类中添加新的域和方法来扩展父类的功能.



### 3.1.3 子类构造器

来给 Person 添加一个构造器:

```java
public Person(int age) {
	super(age);
	age = 10;
}
```

这个关键字 **super** 表示调用超类中含有参数 age 的有参构造器,由于子类 Person 不可以访问 Creature 的私有域,所以必须调用超类的构造器对这部分私有域进行初始化,使用 **super** 关键字就可以了.

🚩 **如果子类的构造器没有显示地调用超类的构造器,则将自动地调用超类的默认构造器(无参构造器)**.如果超类没有无参构造器,并且在子类的构造器中有没有显示地调用超类的其他构造器,则 Java 编译器报错.



### 3.1.4 多态

有一个用来判断是否应该设计为继承关系的简单规则,这就是 *"is-a"* 规则,它表明子类的每个对象也是超类的对象.例如,每个经理都是雇员,因此,将 Manager 类设计为 Employee 类的子类是显而易见的.

例如,可以将一个子类的对象赋值给超类变量:

```java
Employee e = new Manager();
```

在 Java 程序设计语言中,对象变量时**多态的**.一个 Employee 变量既可以引用一个 Employee 类对象,也可以引用一个 Employee 类的任何一个子类的对象(例如: Manager, Executive, Secretary 等).

然而,不可以将一个超类的引用赋值给子类变量.例如,下面的赋值是非法的:

```java
Manager m = new Employee();  // Error
```

原因很清楚,不是所有的雇员都是经理,如果赋值成功, m 有可能引用了一个不是经理的 Employee 对象.



### 3.1.5 理解方法调用

弄清楚如何在对象上应用方法调用非常重要.下面假设要调用 x.f(args),隐式参数 x 声明为类 C 的一个对象.下面是调用过程的详细描述:

1. 编译器查看对象的声明类型和方法名称.假设调用 x.f(param),且隐式参数 x 声明为 C 类的对象.需要注意的是: 有可能存在多个名字为 f,但参数类型不一样的方法.例如,可能存在方法 f(int) 和方法 f(String).编译器将会一一列举 C 类中名为 f 的方法和其超类中访问属性为 public 且名为 f 的方法(超类的私有方法不可以访问).编译器此时获得所有可能被调用的候选方法.
2. 接下来,编译器将查看调用方法时提供的参数类型.如果在所有名为 f 的方法中存在一个与提供的参数类型完全匹配,就选择这个方法.这个过程被称为**重载解析 (overloading resolution)**.例如,对于调用 x.f("Hello") 来说,编译器将会挑选 f(String),而不是 f(int).由于允许类型转换,所以这个过程可能很复杂.如果编译器没有找到与参数类型匹配的方法,或者发现经过类型转换后有多个方法与之匹配,就会报错.编译器此时获得需要调用的方法的名字和参数类型.
3. 如果是 private 方法, static 方法, final 方法或者是构造器,那么编译器将可以准确地知道调用哪个方法,我们将这种调用方法称为**静态绑定 (static binding)**.与此对应的是,调用的方法依赖于隐式参数的实际类型,并且在运行时实现动态绑定.
4. 当程序运行,并且采用动态绑定调用方法时,虚拟机一定调用与 x 所引用对象的**实际**类型最合适的那个类的方法.假设 x 的实际类型时 D,它是 C 类的子类.如果 D 类定义了方法 f(String) ,就直接调用它.否则,将在 D 类的超类中寻找 f(String),以此类推.

每次调用方法都要进行搜索,时间开销相当大.因此,虚拟机预先为每个类创建了一个**方法表 (method table)**,其中列出了所有方法的签名和实际调用的方法.这样一来,在真正调用方法的时候,虚拟机仅查找了这个表就行了.在前面的例子中,虚拟机搜索 D 类的方法表,以便寻找与调用 f(String) 相匹配的方法.这个方法既有可能是 D.f(String),也有可能是 X.f(String),这里的 X 是 D 的超类.

动态绑定有一个非常重要的特性: 无需对现存的代码进行修改,就可以对程序进行扩展.

> 在覆盖一个方法的时候,子类方法不能低于超类方法的可见性.特别是超类方法是 public,子类方法一定要声明为 public.



### 3.1.6 final类和方法

有时候,你可能不想让一个类被继承.不允许被扩展的类被称为 final 类.如果在定义类的时候使用了 final 关键字就表明这个类是 final 类.例如定义一个 final 类:

```java
public final class Executive extends Manager {

}
```

类中的特定方法也可以被声明为 final.如果这样做,子类就不能覆盖这个方法(final 类中的所有方法自动地被声明为 final 方法,这是一个隐式的过程).



### 3.1.7 强制类型转换

要想将一个对象转为另一个类型,只要使用 Java 提供的强制转换语法即可,比如说将 Employee 向下转为 Manager,只有向下转型才是强制的,向上转型是自动的,隐式的.

```java
Employee e = new Manager();
Manager m = (Manager) e;
```

但是,可能实际类型和你要转的类型不一致,这时候就会产生 **ClassCastException** 异常.如果没有捕获这个异常,程序就会终止.因此才类型转换之前,判断能否转型:

```java
if (e instanceof Manager) {
	Manager m = (Manager) e;
}
```

总结:

- 只能在继承层次内进行类型转换
- 在将超类转成子类之前,应该使用 *instanceof* 关键字进行检查

> 如果 e 是 null,那么返回 false.因为 null 没有引用任何对象.



### 3.1.8 抽象类



### 3.1.9 protected关键字

##  3.2 Object类



## 3.3 泛型数组列表



## 3.4 对象包装器与自动装箱



## 3.5 可变参数



## 3.6 枚举类



## 3.7 反射



## 3.8 继承设计技巧
