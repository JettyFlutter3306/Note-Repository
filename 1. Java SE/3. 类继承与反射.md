# 三. 继承与反射

这一章主要介绍面向对象程序设计的另外一个基本概念,那就是**继承 (inheritance)**.利用继承,可以基于已存在的类构造一个新类.继承已存在的类就是复用这些类的方法和域.这是 Java 程序设计中的一项核心技术.

本章还介绍了**反射 (reflection)**的概念.反射式值在程序运行期间发现更多的类及其属性的能力.这是一个功能强大的特性,使用起来比较复杂.

## 3.1 类,超类和子类

### 3.1.1 定义子类

使用 `extends` 关键字来继承一个类:

```java
class Creature {
    private int age;
    
    public Creature(int age) {
        this.age = age;
    }
    
	public void eat() {
        
    }    
}

class Person extends Creature {
	
}
```

关键字 `extends` 表明正在构造的新类派生于一个已存在的类.已存在的类称为**超类 (super class)**,**基类 (base class)** 或 **父类 (parent class)**.新类称为**子类 (subclass)**,**派生类 (derived class)** 或 **孩子类 (child class)**.超类和子类是 Java 程序员最常用的两个术语,而了解其他语言的程序员可能更加偏爱使用父类和孩子类,这些都是继承时使用的术语.



### 3.1.2 覆盖方法

超类中的有些方法对子类并不一定适用.具体来说 Person 类继承了 eat 方法,但是那是父类的行为,子类可以对父类进行覆盖,因为人类有人类吃东西的方法.为此,需要提供一个新的方法来**覆盖 (override)**超类中的这个方法,这同时也称为**重写**:

```java
public class Person extends Creature {
	@Override
    public void eat() {
    	System.out.println("用筷子吃饭...");    
    }
}
```

子类不可以直接访问父类的**私有域 **,必须得要使用父类提供的 **getter** 来访问.比如说访问上面的 *age* 属性,得要使用父类提供的 *getAge* 方法才可以访问,没有这个 **getter** 就无法访问,但是子类是**隐式地**拥有这个属性的.

同时,子类也可以在本类中添加新的域和方法来扩展父类的功能.



### 3.1.3 子类构造器

来给 Person 添加一个构造器:

```java
public Person(int age) {
	super(age);
	age = 10;
}
```

这个关键字 **super** 表示调用超类中含有参数 age 的有参构造器,由于子类 Person 不可以访问 Creature 的私有域,所以必须调用超类的构造器对这部分私有域进行初始化,使用 **super** 关键字就可以了.

🚩 **如果子类的构造器没有显示地调用超类的构造器,则将自动地调用超类的默认构造器(无参构造器)**.如果超类没有无参构造器,并且在子类的构造器中有没有显示地调用超类的其他构造器,则 Java 编译器报错.



### 3.1.4 多态

有一个用来判断是否应该设计为继承关系的简单规则,这就是 *"is-a"* 规则,它表明子类的每个对象也是超类的对象.例如,每个经理都是雇员,因此,将 Manager 类设计为 Employee 类的子类是显而易见的.

例如,可以将一个子类的对象赋值给超类变量:

```java
Employee e = new Manager();
```

在 Java 程序设计语言中,对象变量时**多态的**.一个 Employee 变量既可以引用一个 Employee 类对象,也可以引用一个 Employee 类的任何一个子类的对象(例如: Manager, Executive, Secretary 等).

然而,不可以将一个超类的引用赋值给子类变量.例如,下面的赋值是非法的:

```java
Manager m = new Employee();  // Error
```

原因很清楚,不是所有的雇员都是经理,如果赋值成功, m 有可能引用了一个不是经理的 Employee 对象.



### 3.1.5 理解方法调用

弄清楚如何在对象上应用方法调用非常重要.下面假设要调用 x.f(args),隐式参数 x 声明为类 C 的一个对象.下面是调用过程的详细描述:

1. 编译器查看对象的声明类型和方法名称.假设调用 x.f(param),且隐式参数 x 声明为 C 类的对象.需要注意的是: 有可能存在多个名字为 f,但参数类型不一样的方法.例如,可能存在方法 f(int) 和方法 f(String).编译器将会一一列举 C 类中名为 f 的方法和其超类中访问属性为 public 且名为 f 的方法(超类的私有方法不可以访问).编译器此时获得所有可能被调用的候选方法.
2. 接下来,编译器将查看调用方法时提供的参数类型.如果在所有名为 f 的方法中存在一个与提供的参数类型完全匹配,就选择这个方法.这个过程被称为**重载解析 (overloading resolution)**.例如,对于调用 x.f("Hello") 来说,编译器将会挑选 f(String),而不是 f(int).由于允许类型转换,所以这个过程可能很复杂.如果编译器没有找到与参数类型匹配的方法,或者发现经过类型转换后有多个方法与之匹配,就会报错.编译器此时获得需要调用的方法的名字和参数类型.
3. 如果是 private 方法, static 方法, final 方法或者是构造器,那么编译器将可以准确地知道调用哪个方法,我们将这种调用方法称为**静态绑定 (static binding)**.与此对应的是,调用的方法依赖于隐式参数的实际类型,并且在运行时实现动态绑定.
4. 当程序运行,并且采用动态绑定调用方法时,虚拟机一定调用与 x 所引用对象的**实际**类型最合适的那个类的方法.假设 x 的实际类型时 D,它是 C 类的子类.如果 D 类定义了方法 f(String) ,就直接调用它.否则,将在 D 类的超类中寻找 f(String),以此类推.

每次调用方法都要进行搜索,时间开销相当大.因此,虚拟机预先为每个类创建了一个**方法表 (method table)**,其中列出了所有方法的签名和实际调用的方法.这样一来,在真正调用方法的时候,虚拟机仅查找了这个表就行了.在前面的例子中,虚拟机搜索 D 类的方法表,以便寻找与调用 f(String) 相匹配的方法.这个方法既有可能是 D.f(String),也有可能是 X.f(String),这里的 X 是 D 的超类.

动态绑定有一个非常重要的特性: 无需对现存的代码进行修改,就可以对程序进行扩展.

> 在覆盖一个方法的时候,子类方法不能低于超类方法的可见性.特别是超类方法是 public,子类方法一定要声明为 public.



### 3.1.6 final类和方法

有时候,你可能不想让一个类被继承.不允许被扩展的类被称为 final 类.如果在定义类的时候使用了 final 关键字就表明这个类是 final 类.例如定义一个 final 类:

```java
public final class Executive extends Manager {

}
```

类中的特定方法也可以被声明为 final.如果这样做,子类就不能覆盖这个方法(final 类中的所有方法自动地被声明为 final 方法,这是一个隐式的过程).



### 3.1.7 强制类型转换

要想将一个对象转为另一个类型,只要使用 Java 提供的强制转换语法即可,比如说将 Employee 向下转为 Manager,只有向下转型才是强制的,向上转型是自动的,隐式的.

```java
Employee e = new Manager();
Manager m = (Manager) e;
```

但是,可能实际类型和你要转的类型不一致,这时候就会产生 **ClassCastException** 异常.如果没有捕获这个异常,程序就会终止.因此才类型转换之前,判断能否转型:

```java
if (e instanceof Manager) {
	Manager m = (Manager) e;
}
```

总结:

- 只能在继承层次内进行类型转换
- 在将超类转成子类之前,应该使用 *instanceof* 关键字进行检查

> 如果 e 是 null,那么返回 false.因为 null 没有引用任何对象.



### 3.1.8 抽象类

如果自下而上在类的继承层次结构中上移,位于上层的类更具有通用性,甚至可能更加抽象.从某种角度上看,祖先类更加通用,人们只将它作为派生其他类的基类,而不作为想使用特定的实例类.如此,就有了抽象类存在的意义.

声明一个抽象类:

```java
public abstract class Person {
    private String name;
    
    public Person(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
	public abstract String getDescription();
}
```

**除了接口,只有抽象类才可以声明抽象方法**,要想一个类有抽象方法,那么只需要使用 *abstract* 关键字修饰类名即可.除了抽象方法之外,抽象类还可以包含具体数据和具体方法.例如,抽象类 Person 还可以保存 name 变量和返回 name 的方法,也就是**具体方法**,在抽象类中可以实现一个方法,但不是抽象的.

类即使不含抽象方法,也可以声明为抽象类.抽象类**不可以被实例化**,也就是说,将一个类声明为 *asbtract*,就不能使用 *new* 关键字创建对象,但是可以创建一个具体子类对象.

若一个子类继承了一个抽象类,那么**一定要提供对应构造方法**.否则编译不通过,因为不提供对应的构造方法父类的域无法初始化,这和没有调用父类对应提供的 *super* 方法问题是类似的.



### 3.1.9 protected关键字

有些时候，如果你希望超类中的某些方法允许被子类访问，或者允许子类的方法访问超类中的某个域，那就需要使用 **protected** 关键字。

在实际使用中，要谨慎使用 **protected** 属性。假设需要将设计的类提供给其他程序员使用，而在这个类中设置了一些受保护的域，由于其他开发者可以由这个类再派生出新类，并访问其中的受保护域，在这种情况下，如果需要对这个类的实现进行修改，就必须通知所有使用这个类的开发者，这就违背了 OOP 提倡的数据封装原则。

在 Java 中，受保护部分对其所有子类及同包的所有其他的类都可见，这与 C++ 中的保护机制稍有不同。

总结一下 Java 用于控制可见性的 4 个访问修饰符：

1. 仅对本类可见——**private**

2. 对所有的类可见——**public**

3. 对本包和所有的子类可见——**protected**

4. 对本包可见——默认，不需要修饰符，在接口中使用 **default** 关键字

   

##  3.2 Object类

Object 类是 Java 中所有类的始祖，在 Java 中每个类都是由它扩展而来的。但是并不需要这样写：

```java
public class Employee extends Object
```

没有指出超类时，默认 Object 类就是这个类的超类。可以使用 Object 类来引用任何类型的对象：

```java
Object obj = new Employee("Steve", 30000);
```



### 3.2.1 equals方法

Object 类中的 equals 方法用于检测一个对象是否等于另一个对象。在 Object 类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，它们就一定相等。

在子类中定义 equals 方法时，首先调用超类的 equals 方法。如果检测失败，对象就不可能相等。如果超类中的域都相等，就需要比较子类中的实例域。



### 3.2.2 编写equals方法建议

1. 显示参数命名为 otherObejct，稍后需要将它转换成另一个叫做 other 的变量。
2. 检测 this 与 otherObject 是否引用同一个对象：

```java
if (this == otherObject) return true;
```

3. 检测 otherObejct 是否为 null，如果为 null，返回 false。

```java
if (otherObject == null) return false;
```

4. 比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测：

```java
if (getClass() != otherObject.getClass()) return false;
```

如果所有的子类都拥有统一的语义就使用 `instanceof` 检测：

```java
if (!(otherObject instanceof ClassName)) return false;
```

5. 将 otherObject 转换为相应的类类型变量：

```java
ClassName other = (ClassName) otherObject;
```

6. 现在开始对所有需要比较的域进行比较。使用 `==` 比较基本类型域，使用 equals 方法比较对象域。如果所有的域都匹配，就返回 true，否则返回 false。

> 对于数组类型的域，可以使用静态的 Arrays.equals() 方法检测相应的数组元素是否相等。



### 3.2.3 hashCode方法

散列码(hash code)是由对象导出的一个整形值。散列码是没有规律的。如果 x 和 y 是两个不同的对象，x.hashCode() 与 y.hashCode() 基本上不会相同。

String 类使用下列算法计算散列码：

```java
int hash = 0;
for (int i = 0; i < length(); i++) {
    hash = 31 * hash + charAt(i);
}
```

由于 hashCode 方法定义在 Object 类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。

**如果重写了 equals 方法，那么就必须要重新定义 hashCode 方法，以便于用户可以将对象插入到散列表中**。hashCode 方法应该返回一个整形数值(也可以是负数)，并合理地组合实例域的散列码，以便于让各个不同的对象产生的散列码更加均匀。

> 如果存在数组类型的域，那么可以使用静态的 Arrays.hashCode 方法计算一个数组的散列码。



### 3.2.4 toString方法

在 Object 中还有一个重要的方法，那就是 toString 方法，它用于返回表示对象值的字符串。

绝大多数类的 toString 方法都遵循这样的格式：类的名字，随后是一对花括号括起来的域值。

如果 x 是任意一个对象，并调用 `System.out.println(x);`

println 方法就会直接调用 x.toString()，并打印输出得到的字符串。若类没有覆盖 toString 方法，那么直接打印就会显示全路径类名和内存地址的散列码。



## 3.3 泛型数组列表



## 3.4 对象包装器与自动装箱



## 3.5 可变参数



## 3.6 枚举类



## 3.7 反射



## 3.8 继承设计技巧
