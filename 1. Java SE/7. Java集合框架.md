# 七. 集合

## 7.1 Java集合框架

Java 最初的版本只为最常用的数据结构提供了很少的一组类：Vector、Stack、Hashtable、BitSet 与 Enumeration 接口，其中的 Enumeration 接口提供了一种用于访问任意容器中各个元素的抽象机制。

随着 Java SE 1.2 问世，设计人员感到是推出一组功能完善的数据结构的时机了。面对一大堆相互矛盾的设计策略，他们希望让类库规模小且易于学习，而不希望像 C++ 的“标准模板库”(即 STL)那样复杂，但却又希望能够得到 STL 率先推出的“泛型算法”所具有的有点。他们希望将传统的类融入新的框架中。与所有的集合类库设计者一样，他们必须做到一些艰难的选择，于是，在整个设计过程中，他们做出了一些独具特色的设计决定。

与现代的数据结构类库的常见情况一样，Java 集合类库也将**接口(interface)**与**实现(implementation)**分离。

### 7.1.1 Collection接口

在 Java 类库中，集合类的基本接口是 Collection 接口。这个接口有两个基本方法：

```java
public interface Collection<E> {
    boolean add(E element);
    Iterator<E> iterator();
    ...
}
```

除了这两个方法之外，还有其他几个方法。

*add* 方法用于向集合中添加元素。如果添加元素确实改变了集合就返回 true，如果集合没有发生变化就返回 false。

*iterator* 方法用于返回一个实现了 Iterator 接口的对象。可以使用这个迭代器对象依次访问集合中的元素。



### 7.1.2 迭代器

Iterator 接口包含 4 个方法：

```java
public interface Iterator<E> {
    E next();
    boolean hasNext();
    void remove();
    default void forEachRemaining(Consumer<? super E> action)
}
```

通过反复调用 *next* 方法，可以逐个访问集合中的每个元素。但是，如果到达了集合的末尾，*next* 方法将抛出一个 NoSuchElementException。因此，需要在调用 *next* 之前调用 *hasNext* 方法。如果迭代器对象还有多个供访问的元素，这个方法就返回 true。如果想要查看集合中的所有元素，就请求一个迭代器，并在 *hashNext* 返回 true 时反复调用 *next* 方法。

```java
Collection<String> col = ...;
Iterator<String> it = col.iterator();
while (it.hasNext()) {
    String element = it.next();
    ...
}
```

用“for each”循环可以更加简单地表示同样的循环操作：

```java
for (String e : col) {
    ...
}
```

编译器简单地将“for each”循环翻译为带有迭代器的循环。

**“for each”循环可以与任何实现了 Iterable 接口的对象一起工作，这个接口只包含一个抽象方法：**

```java
public interface Iterable<E> {
    Iterator<E> iterator();
    ...
}
```

Collection 接口扩展了 Iterable 接口。因此，对于标准库中的任何集合都可以使用“for each”循环。

Iterator 接口的 *remove* 方法将删除上次调用 *next* 方法时返回的元素。在大多数情况下，在决定删除某个元素之前应该看一下这个元素是很具有实际意义的。然而，如果想要删除指定位置上的元素，仍然需要越过这个元素。

**更重要的是，对 *next* 方法和 *remove* 方法的调用具有互相依赖性。如果调用 *remove* 之前没有调用 *next* 将是不合法的。**如果这样做，将会抛出一个 `IllegalStateException` 异常。

如果想删除两个相邻的元素，不能直接地像这样调用：

```java
it.remove();
it.remove();  // Error
```

相反地，必须先调用 *next* 越过将要删除的元素。

```java
it.remove();
it.next();
it.remove();  // OK
```



### 7.1.3 泛型使用方

由于 Collection 与 Iterator 都是泛型接口，可以编写操作任何集合类型的实用方法。

Java 类库的设计者认为：这些实用方法中的某些方法非常有用，应该将它们提供给用户使用。这样，类库的使用者就不必自己重新构建这些方法了。*contains* 就是这样一个实用方法。

事实上，Collection 接口声明了很多有用的方法，所有的实现类都必须提供这些方法。

当然，如果实现 Collection 接口的每一个类都要提供如此多的例行方法将是一件很烦人的事情。为了能够让实现者更容易地实现这个接口，Java 类库提供了一个类 AbstractCollection，它将基础方法 *size* 和 *iterator* 抽象化了，但是在此提供了例行方法。

此时一个具体的集合类可以扩展 AbstractCollection 类了。现在要由具体的集合类提供 *iterator* 方法。而 *contains* 方法已由 AbstractCollection 超类提供了。然而，如果子类有更加有效的方式实现 *contains* 方法，也可以由子类提供，就这点而言，没有什么限制。

*java.util.Collection\<E\>*：

- `Iterator<E> iterator()` 返回迭代器。
- `int size()` 返回元素个数。
- `boolean isEmpty()` 判空。
- `boolean contains(Object obj)` 是否包含。
- `boolean containsAll(Collection<?> other)` 判断是否包含 other 集合的所有元素。
- `boolean add(Object element)` 添加元素到集合中。如果改变了集合返回 true。
- `boolean addAll(Collection<? extends E> other)` 将 other 集合所有元素添加到集合中。

- `boolean remove(Object obj)` 删除元素。
- `boolean removeAll(Collection<?> other)` 批量删除。
- `default boolean removeIf(Predicate<? super E> filter)` 谓词条件删除元素。
- `void clear()` 清空集合。
- `boolean retainAll(Collection<?> other)` 删除所有与 other 集合不同的元素。
- `Object[] toArray()` 返回这个集合的对象。
- `<T> T[] toArray(T[] arrayToFill)` 如果 arrayToFill 足够大，就将集合中的元素填入这个数组中，剩余空间填补 null，否则，分配一个新数组，成员类型与 arrayToFill 成员类型一样，其长度等于集合大小，并填充集合元素。

*java.util.Iterator\<E\>*：

- `boolean hasNext()` 如果存在可访问的元素，返回 true。
- `E next()` 返回将要访问的下一个对象。如果已经到达了集合的尾部，将抛出一个 NoSuchElementException 异常。
- `void remove()` 删除上次访问的对象。这个方法必须紧跟在访问一个元素之后执行。如果上次访问之后，集合已经发生了变化，这个方法将抛出一个 `IllegalStateException`。



### 7.1.4 集合框架中的接口

![image-20220701090347906](asset/chapter7/:Users:element:Library:Application Support:typora-user-images:image-20220701090347906.png)

集合有两个基本接口：Collection 和 Map。

LIst 是一个有序集合(ordered collection)。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，或者使用一个整数索引来访问。后一种方法称为随机访问(Random Access)，因为这样可以按任意顺序访问元素。与之不同，使用迭代器访问时，必须顺序地访问元素。

ListIterator 接口是 Iterator 的一个子接口。它定义了一个方法用于在迭代器位置前面增加一个元素：

```java
void add(E element);
```

Set 接口等同于 Collection 接口，不过其方法的行为有更严谨的定义。集(Set)的 *add* 方法不允许增加重复的元素。要适当地定义集的 *equals* 方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素同样的顺序。*hashCode* 方法的定义要保证包含相同元素的两个集会得到相同的散列码。



## 7.2 具体的集合

除了以 Map 结尾的类之外，其他类都实现了 Collection 接口，而以 Map 结尾的类实现了 Map 接口。

<center>Java 库中的具体集合</center>

| 集合类型        | 描述                                               |
| --------------- | -------------------------------------------------- |
| ArrayList       | 一种可以动态增长和缩减的索引序列                   |
| LinkedList      | 一种可以在任何位置进行高效插入和删除操作的有序序列 |
| ArrayDeque      | 一种用循环数组实现的双端队列                       |
| HashSet         | 一种没有重复元素的无序集合                         |
| TreeSet         | 一种有序集                                         |
| EnumSet         | 一种包含枚举类型的集                               |
| LinkedHashSet   | 一种可以记住元素插入次序的集                       |
| PriorityQueue   | 一种允许高效删除最小元素的集合                     |
| HashMap         | 一种键/值关联的数据结构                            |
| TreeMap         | 一种键/值有序排列的映射表                          |
| EnumMap         | 一种键/值属于枚举类型的映射表                      |
| LinkedHashMap   | 一种可以记住键/值项添加次序的映射表                |
| WeakHashMap     | 一种其值无用武之地后可以被垃圾回收器回收的映射表   |
| IdentityHashMap | 一种用 == 而不是 equals 比较键值的映射表           |

![image-20220701100848110](asset/chapter7/:Users:element:Library:Application Support:typora-user-images:image-20220701100848110.png)



### 7.2.1 链表

**链表(linked list)**可以进行高效的插入删除操作，链表将每个对象存放在独立的结点中，每个结点还存放着序列中下一个结点的引用。在 Java 语言中，所有链表实际上都是**双向链表**——即每个结点还存放着指向前驱结点的引用。

e.g. 链表插入删除元素：

```java
List<String> staff = new LinkedList<String>() {{
    add("Amy");
    add("Bob");
    add("Carl");
}};
Iterator it = staff.iterator();
String first = it.next();
String second = it.next();
it.remove();
```

但是链表和泛型集合之间有一个重要的区别。链表是一个**有序集合(ordered collection)**，每个对象的位置十分重要。LinkedList.add 方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表中间。由于迭代器是描述集合中位置的，所以这种依赖于位置的 *add* 方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。

要想在链表中添加元素，推荐使用 ListIterator 接口：

```java
List<String> staff = new LinkedList<String>() {{
    add("Amy");
    add("Bob");
    add("Carl");
}};
ListIterator<String> it = staff.listIterator();
it.next();
it.add("Juliet");
```

如果多次调用 *add* 方法，将按照提供的次序把元素添加到链表中。它们被依次添加到迭代器当前位置之前。

当用一个刚刚由 Iterator 方法返回，并且指向链表表头的迭代器调用 *add* 操作时，新添加的元素将变成列表的新表头。当迭代器越过链表的最后一个元素时，添加的元素将变成列表的新表尾。如果链表有 n 个元素，有 n + 1 个位置可以添加新元素。这些位置与迭代器的 n + 1 个可能得位置相对应。

*set* 方法用一个新元素取代调用 *next* 和 *previous* 方法返回的上一个元素。例如，下列代码将用一个新值取代链表的第一个元素：

```java
ListIterator<String> it = list.iterator();
String oldValue = it.next();
it.set(newValue);  // sets first element to newValue
```

可以想象，如果在某个迭代器修改集合时，另一个迭代器对其进行遍历，一定会出现混乱的状况。例如，一个迭代器指向另一个迭代器刚刚删除的元素前面，现在这个迭代器就是无效的，并且不应该使用。链表迭代器的设计使它能够检测到这种修改。如果迭代器发现它的集合被另一个迭代器修改了，或者是被集合自身的方法修改了，就会抛出一个 ConcurrentModificationException 异常。

e.g.

```java
List<String> list = ...;
ListIterator<String> it1 = list.iterator();
ListIterator<String> it2 = list.iterator();
it1.next();
it1.remove();
it2.next();  // throws ConcurrentModificationException
```

由于 it2 检测出这个链表被从外部修改了，所以对 it2.next 的调用抛出一个 ConcurrentModificationException 异常。

为了避免发生并发修改的异常，请遵循下述的简单规则：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器。

有一种简单的方法可以检测到并发修改问题。集合可以跟踪改写操作(诸如添加或删除元素)的次数。每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检查自己改写操作的计数值是否与集合的改写操作计数值一致。如果不一致，抛出一个 ConcurrentModificationException 异常。

对于并发修改列表的检测有一个奇怪的例外。链表只负责跟踪对列表的结构性修改，例如，添加元素、删除元素。*set* 方法不被视为结构性修改。可以将多个迭代器附加起来，所有的迭代器都调用 *set* 方法对现有结点的内容进行修改。





















## 7.3 映射



## 7.4 视图与包装器



## 7.5 算法



## 7.6 遗留的集合