# 算法刷题套路

# 一. 位运算

## 1.1 异或运算

在 Java 中异或运算使用  `^` 符号,异或运算的性质：

1. `0 ^ N = N`
2. `N ^ N = 0`

概括讲就是: 0 跟任何数 N 异或得到的结果都是 N,任何数 N 跟自己异或得到的结果都是 0.

## 1.2 两数交换

通常情况下,我们交换两个数的传统方式都是要申请一个临时变量空间,然后进行交换.但是在了解了异或性质之后我们就可以使用异或运算来实现两数交换,这种方式不需要任何额外的内存空间,而且效率更高.

```java
public static void main(String[] args) {
    int a = 10;
    int b = 20;
    a = a ^ b;  // a + b
    b = a ^ b;  // a - b
    a = a ^ b;  // a - b
}
```

分析一下过程:

1) 初始化 a , b.
2) 执行 `a = a ^ b` 此时 a = 10 ^ 20
3) 执行 `b = a ^ b` 此时 b = 10 ^ 20 ^ 20 = 10
4) 执行 `a = a ^ b` 此时 a = 10 ^ 20 ^ 10 = 20

由于 Java **值传递**的性质,我们通常不使用方法来交换两数,因为这只是进行了一次值拷贝,并没有改变原有变量的值.但是可以用来交换数组两个不同索引的值.

```java
public static void swap(int[] keys, int i, int j) {
    if (i != j) {
        keys[i] = keys[i] ^ keys[j];
        keys[j] = keys[i] ^ keys[j];
        keys[i] = keys[i] ^ keys[j];
    }
}
```

> 分析: 为什么要求两个位置不相同? 假如两个位置的数相同,刚开始 keys[i] = 0 了,然后底下就不用看了,那个位置的数被你直接改变成 0 值了,也就是说你这次交换失败了!



## 1.3 找出出现奇数次的数

要求如下:

​		在一个数组中找出出现**奇数次**的数,假设其他的数出现的次数为偶数.

思路:

​		根据异或的性质,一个数出现偶数次,那么让这些数进行异或最后的结果就变成 0 了.比如说: 出现次数为偶数的数为 a ,偶数个 a 在一起异或:

​				`a ^ a ^ a ^ a ^ ... ^ a (偶数个) = 0 `

​		那么最后只剩下出现次数为奇数次的数,这样代码就水到渠成了.	

```java
public static int findOddTimesNum(int[] arr) {
    int xor = 0;
    for (int j : arr) {
        xor ^= j;
    }
    return eor;
}
```



## 1.4 找出两个出现奇数次的数

要求如下:

​		在一个数组中找出**两个**出现次数为奇数的数,规定其他的数出现的次数为偶数.而且这两个数是**不同的数**.

思路:

​		假设这两个数分别为 a , b.首先还是定义一个 *xor* 异或变量,遍历 arr ,然后对每一个数进行异或操作,最后就得到 *xor = a ^ b*.假设 a 和 b 的二进制形式在某一个位置上是不同的,也就是说在 N 位置上一个是 1,一个是 0.那么数组 arr 整个就**可以分成两组**,一组就是 N 位置上是 1,还有一组就是 N 位置上为 0.

​		如何得到 N?

​		很简单,**只需要将 xor 取反再跟自己异或即可得到**.得到位置 N 后,对 arr 进行二次遍历异或,过滤出 N 位置上为 0 的数和不为 0 的数,下列代码中 *onlyOne* 就是最终 N 位置上为 1 的那个数在一起异或的结果,**也就是 a 和 b 之中 N 位置上为 1 的数**,假设是 a.然后再拿  *xor* 和 *onlyOne* 异或即可得到 b.

```java
public static int[] findTheTwoNumberOddTimes(int[] arr) {
    int[] ans = new int[2];
    int xor = 0;
    for (int i : arr) {
        xor ^= i;
    }
    
    // 现在只得到两个出现次数为奇数的数异或之后的结果
    // 得到最右边1的位置
    int rightOne = xor & (-xor);
    int onlyOne = 0;
    
    for (int j : arr) {
        if ((j & rightOne) != 0) {  // 表示在最右边的位置上存在1
            onlyOne ^= j;
        }
    }
    ans[0] = onlyOne;
    ans[1] = xor ^ onlyOne;
    return ans;
}
```



## 1.5 找出出现K次的数

要求如下:

​		一个数组中有一个数出现 k 次,其他数都出现了 m 次, m > 1, k < m,编写程序找到出现 k 次的数,要求额外空间复杂度 O(1),时间复杂度 O(N).

```java
public static int findKTimes(int[] arr, int k, int m) {
    int[] t = new int[32];

    // t[0]代表0位置的1出现了几次
    // t[i]代表i位置的1出现了几次
    for (int num : arr) {
        for (int i = 0; i < 31; i++) {
            // 表示在i位置上不是0
            if (((num >> i) & 1) != 0) {
                t[i]++;
            }
        }
    }

    int ans = 0;
    for (int i = 0; i < 31; i++) {
        if (t[i] % m != 0) {  // 在第i位置上有1
            ans |= (1 << i);
        }
    }
    return ans;
}
```



# 二. 基础的数据结构

## 2.1 链表



## 2.2 栈和队列



## 2.3 理解递归



## 2.4 Master公式



## 2.5 哈希表和有序表



# 三. 归并和快速排序



# 四. 堆排序



# 
