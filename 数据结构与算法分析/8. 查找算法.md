# 八. 查找算法

查找是数据结构中的一种基本操作,查找效率决定计算机某些系统应用的效率.查找算法依赖于数据结构,不同的数据结构需要采用不用的查找算法.因此,如何有效地组织数据,如何根据数据结构的特点快速,高效地获得查找结果,是数据结构处理的核心问题.

## 8.1 顺序查找

在顺序表和链表中查找对应元素都是属于线性查找,时间复杂度最好情况 **O(1)** ,最坏情况是 **O(N)** ,平均时间复杂度为 **O(N)** .

顺序表查找元素示例代码,结果返回数组的索引:

```java
public static int linearSearch(int[] arr, int target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}
```

假如没有找到对应元素,则返回 **-1** .

## 8.2 二分查找

**二分查找(Binary Search)**是一种典型的采用分治策略的算法,它将问题分解为规模更小的子问题,分而治之,逐一解决.二分查找的两个条件是:**顺序存储**,**数据元素有序**.

已知数组元素**升序排序**,设 **key** 是包含关键字的数据元素, begin, end 表示查找子序列的范围.

算法描述如下:

1. 从子序列的中间位置 mid 开始比较,如果 key 与 mid 元素相等,则查找成功.否则,根据 key 大小缩小查找范围,若 key 比较小,则继续在子序列的前半段查找,反之,继续在后半段查找.
2. 重复步骤 1,直到查找成功.当 begin, end 表示范围无效时,表示查找不成功.

### 8.2.1 等值查找

e.g,

```java
public static int binarySearch(int[] arr, int target) {
    if (arr == null || arr.length == 0) {
        return -1;
    }
    return binarySearch(arr, target, 0, arr.length - 1);
}

private static int binarySearch(int[] arr, int target, int start, int end) {
    while (start <= end) {
        // 防止数据范围溢出,加括号是因为位运算优先级比加减优先级低
    	int mid = start + ((end - start) >> 1);
        
        if (target == arr[mid]) {
            return mid;
        } else if (target < arr[mid]) {
            end = mid - 1;
        } else {
            start = mid + 1;
        }
    } 
    return -1;  // 查找不成功
}
```



### 8.2.2 找出 ≦ 目标值的最大索引

要求如下:已知一个升序数组和一个目标值 target,要求在数组找出**小于或等于** target 的**最大**索引值.

```java
public static int searchTheBiggestIndex(int[] arr, int target) {

    int start = 0;
    int end = arr.length - 1;
    int index = -1;

    while (start <= end) {
        int mid = start + ((end - start) >> 1);
        if (arr[mid] <= target) {
            index = mid;
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }

    return index;
}
```



### 8.2.3 找出 ≧ 目标值的最小索引

要求如下:已知一个升序数组和一个目标值 target,要求在数组找出**大于或等于** target 的**最小**索引值.

和上面同理,只是方向相反.

```java
public static int searchTheSmallestIndex(int[] arr, int target) {
    int start = 0;
    int end = arr.length - 1;
    int index = -1;

    while (start <= end) {
        int mid = start + ((end - start) >> 1);
        if (arr[mid] >= target) {
            index = mid;
            end = mid - 1;
        } else {
            start = mid + 1;
        }
    }

    return index;
}
```



### 8.2.4 找出数组中第一个极小值

要求如下:在一个数组中找出第一个**极小值**

```java
public static int searchExtremeSmallValue(int[] arr) {
    return 0;
}
```

