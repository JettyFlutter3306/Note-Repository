# GORM

# 一. GORM引入

【1】ORM： 	

即 Object-Relational Mapping，它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的 SQL 语句打交道，只要像平时操作对象一样操作它就可以了。

【2】GORM： 	

gorm 是 go 语言的一个 orm 框架，Golang 写的，开发人员友好的 ORM 库。

【3】中文文档： 	

https://jasperxu.com/Programming/Golang/GORM/

【4】安装GORM： 	

录入安装GORM的命令： 		

```shell
go get github.com/jinzhu/gorm
```



# 二. GORM连接数据库

【1】创建一个数据库：

【2】代码：

```go
package main

import (
    "github.com/jinzhu/gorm"
    _ "github.com/jinzhu/gorm/dialects/mysql"   // 引入mysql的驱动
)

func main() {
    // 连接数据库：
    // Open传入两个参数：
    // 第一个参数：指定你要连接的数据库
    // 第二个参数：指的是数据库的设置信息：
    // 用户名:密码@tcp(ip:port)/数据库名字?charset=utf8&parseTime=True&loc=Local
    // charset=utf8设置字符集
    // parseTime=True为了处理time.Time
    // loc=Local 时区设置，与本地时区保持一致
    db, err := gorm.Open("mysql", "root:root@tcp(localhost:3306)/demo?charset=utf8&parseTime=True&loc=Local")
    if err != nil {
        panic(err) //如果出错，后续代码没有必要执行，想让程序中断，panic来执行即可
    }
    // 数据库资源释放：
    defer db.Close()
}
```



# 三. 创建删除表

【1】代码：

```go
package main

import (
    "fmt"
    "github.com/jinzhu/gorm"
    _ "github.com/jinzhu/gorm/dialects/mysql"
)

type User struct {
    Age int
    Name string
}

func main() {
    db, err := gorm.Open("mysql","root:root@tcp(localhost:3306)/demo?charset=utf8&parseTime=True&loc=Local")
    if err != nil {
        panic(err)
    }
    defer db.Close()
    // 创建表：通常情况下，数据库中新建的标的名字是结构体名字的复数形式，例如结构体User，表名 users
    db.CreateTable(&User{})
    // Table方法可以指定你要创建的数据库的表名
    db.Table("tb_user").CreateTable(&User{})
    // 删除表：
    // db.DropTable(&User{}) //通过&User{}来删除users表
    // db.DropTable("tb_user") //通过"tb_user"删除tb_user表
    // 判断表是否存在：
    flag1 := db.HasTable(&User{})//判断是否有users表
    flag2 := db.HasTable("tb_user")//判断是否有tb_user表
}
```



# 四. 单表CRUD

【1】代码：

```go
package main

import (
    "fmt"
    "github.com/jinzhu/gorm"
    _ "github.com/jinzhu/gorm/dialects/mysql"
)

type User struct {
        Age int
        Name string
}

func main() {
    db, err := gorm.Open("mysql","root:root@tcp(localhost:3306)/demo?charset=utf8&parseTime=True&loc=Local")
    if err != nil {
        panic(err)
    }
    defer db.Close()
    
    db.CreateTable(&User{})

    // crud
    // 增加数据：
    // db.Create(&User{Age:18, Name:"洛必达"})
    // 查询数据：第一个参数：查询出来的数据的载体：
    var user User
    db.First(&user, "age = ?", 18)
    fmt.Println(myuser)
    
    // 更新数据：
    // 需要做的：先查询，再更新
    db.Model(&user).Update("age", 30)
    db.Model(&user).Update("name", "伯努利")
    // 删除数据：
    // 需要做的：先查询，再删除
    db.Delete(&user)
}
```



# 五. 模型名和表明映射

【1】模型名和表名的映射规则： 	

1. 如果模型名没有驼峰命名，那么表名就是：模型名小写+复数形式： 如模型名 User 表名 users 	

2. 如果模型名有驼峰命名，那么表名就是：大写变小写并在前面加下划线，最后加复数形式：如模型名UserInfo 表名 user_infos 	
3. 如有模型名有连续的大写字母，那么表名就是：连续的大写字母变小写，驼峰前加下划线，字母变小写，最后加复数形式：如模型名：DBUserInfo 表名 db_user_infos

【2】自定义表名：

```go
package main
import (
    "github.com/jinzhu/gorm"
    _ "github.com/jinzhu/gorm/dialects/mysql"
)

type User struct {
    Age int
    Name string
}

type UserInfo struct {
    Age int
    Name string
}

type DBUserInfo struct {
    Age int
    Name string
}

type MyUser struct {
    Age int
    Name string
}

func (MyUser) TableName() string {
    return "test_my_user"
}

func main() {
    db,err := gorm.Open("mysql", "root:root@tcp(localhost:3306)/demo?charset=utf8&parseTime=True&loc=Local")
    if err != nil {
        panic(err)
    }
    defer db.Close()
    db.CreateTable(&User{})
    db.CreateTable(&UserInfo{})
    db.CreateTable(&DBUserInfo{})
    db.CreateTable(&MyUser{})
}
```



# 六. gorm.Model匿名字段

【1】gorm.Model匿名字段 	

只需要在自己的模型中指定gorm.Model匿名字段，即可在数据库表中包含四个字段：ID，CreatedAt，UpdatedAt，DeletedAt 	

1. ID：主键自增长。
2. CreatedAt：用于存储记录的创建时间。	 		
3. UpdatedAt：用于存储记录的修改时间。
4. DeletedAt：用于存储记录的删除时间，逻辑删除。

【2】代码：

```go
package main
import (
    "github.com/jinzhu/gorm"
    _ "github.com/jinzhu/gorm/dialects/mysql"
)

type User struct {
    gorm.Model      // 增加一个匿名字段：
    Age int
    Name string
}

func main() {
    db,err := gorm.Open("mysql", "root:root@tcp(localhost:3306)/demo?charset=utf8&parseTime=True&loc=Local")
    if err != nil {
        panic(err)
    }
    defer db.Close()
    db.CreateTable(&User{})
}
```

数据库中就多出了 4 个对应的属于 `gorm.Model` 结构体的字段。



# 七. 结构体标签gorm

【1】通过结构体标签gorm来实现表的约束 	

【2】gorm标签属性值： 	

1. `-`： 忽略，不映射这个字段   e.g： `gorm:"-"` ，适合：一些冗余字段，不想在数据库中体现，只想在结构体中体现 		

2. `primary_key`：主键   e.g： `gorm:"primary_key"` 		

如果是想要加联合主键，在每个字段后加入 `gorm:"primary_key"` 即可 		

例如：即可将 StuID 和 Name 作为联合主键

```go
StuID int `gorm:"primary_key"`
Name string `gorm:"primary_key"`
```

3. `AUTO_INCREMENT`：自增   e.g： `gorm:"AUTO_INCREMENT"`

4. `not null`：不为空，默认为空 e.g： `gorm:"not null"`

5. `index`：索引，e.g： `gorm:"index"`

          创建索引并命名：e.g： `gorm:"index:idx_name_code"`

6. `unique_index`：唯一索引   e.g： `gorm:"unique_index"` 唯一性索引unique index和一般索引normal index最大的差异就是在索引列上增加了一层唯一约束。添加唯一性索引的数据列可以为  空，但是只要存在数据值，就必须是唯一的。

7. `unique`：唯一  e.g： `gorm:"unique"`

8. `column`：指定列名  e.g： `gorm:"column:user_name"`

9. `size`：字符串长度,默认为 255  e.g：`gorm:"size:10"`

10. `default`： `default:'男'`  默认值

11. `type`：设置sql类型  e.g： `gorm:"type:int(2)"`

**多个属性值之间用分号分隔!**

【3】结构体代码：

```go
type Student struct {
    StuID int `gorm:"primary_key;AUTO_INCREMENT"`
    Name string `gorm:"not null"`
    Age int `gorm:"unique_index"`
    Email string `gorm:"unique"`
    Sex string `gorm:"column:gender;size:10"`
    Desc string `gorm:"-"`
    Classno string `gorm:"type:int"`
}
```



# 八. 多表操作

## 8.1 一对一关系

【1】首先创建两个结构体：User、UserInfo：

```go
package model

type User struct {
    UserId int `gorm:"primary_key;AUTO_INCREMENT"`
    Age int
    Name string
}

type UserInfo struct {
    InfoID int `gorm:"primary_key;AUTO_INCREMENT"`
    Pic string
    Address string
    Email string
    User User  // 关联关系
    UserId int  // 指定外键
}
```

然后执行 GO Test：

```go
func TestUserTable() {
    db, err := gorm.Open("mysql", "root:root@tcp(localhost:3306)/demo?charset=utf8&parseTime=True&loc=Local")
    if err != nil {
        panic(err)
    }
    defer db.Close()
    db.CreateTable(&model.User{})
    db.CreateTable(&model.UserInfo{})
}

```

> 并没有在数据库中强制加入外键，只是一种关联关系而已。

【2】通过gorm标签来指定外键：（属于关系：关系和外键的指定在同一方）

```go
package model

type User struct {
    UserId int `gorm:"primary_key;AUTO_INCREMENT"`
    Age int
    Name string
}

type UserInfo struct {
    InfoID int `gorm:"primary_key;AUTO_INCREMENT"`
    Pic string
    Address string
    Email string
    // 关联关系
    User User `gorm:"ForeignKey:UserID;AssociationForeignKey:UserId"`
    // 指定外键：
    UserID int
}
```

【3】通过 gorm 标签来指定外键：（包含关系：关系和外键的指定不在同一方）

```go
package model

type User struct {
    UserId int `gorm:"primary_key;AUTO_INCREMENT"`
    Age int
    Name string
    // 指定外键：
    IID int
}
type UserInfo struct {
    InfoID int `gorm:"primary_key;AUTO_INCREMENT"`
    Pic string
    Address string
    Email string
    // 关联关系
    User User `gorm:"ForeignKey:IID;AssociationForeignKey:InfoID"`
}
```



## 8.2 一对多关系

【1】创建两个结构体： 

```go
package model

type Author struct {
    AID int `gorm:"primary_key;AUTO_INCREMENT"`
    Name string
    Age int
    Sex string
    // 关联关系：
    As []Article `gorm:"ForeignKey:AuId;AssociationForeignKey:AID"`
}

type Article struct {
    ArId int `gorm:"primary_key;AUTO_INCREMENT"`
    Title string
    Content string
    Desc string
    // 设置外键：
    AuId int
}
```

执行 GO Test：

```go
func TestArticle(t *testing.T) {
    db, err := gorm.Open("mysql", "root:root@tcp(localhost:3306)/demo?charset=utf8&parseTime=True&loc=Local")
    if err != nil {
        panic(err)
    }
    defer db.Close()
    
    db.CreateTable(&model.Author{})
    db.CreateTable(&model.Article{})
}
```



## 8.3 多对多关系

【1】创建两个结构体：

```go
package model

type Student struct {
    SId int `gorm:"primary_key"`
    SNo int
    Name string
    Sex string
    Age int
    // 关联表：
    Course []Course `gorm:"many2many:Student2Course"`
}

type Course struct {
    CId int `gorm:"primary_key"`
    CName string
    TeacherName string
    Room string
}
```

执行 GO Test：

```go
func TestCourse(t *testing.T) {
    db,err := gorm.Open("mysql", "root:root@tcp(localhost:3306)/demo?charset=utf8&parseTime=True&loc=Local")
    if err != nil {
        panic(err)
    }
    defer db.Close()
    db.CreateTable(&model.Student{})
    db.CreateTable(&model.Course{})
}
```



## 8.4 一对一操作

### 8.4.1 级联添加

```go
func main() {
    db, err := gorm.Open("mysql", "root:root@tcp(localhost:3306)/demo?charset=utf8&parseTime=True&loc=Local")
    if err != nil {
        panic(err)
    }
    defer db.Close()
    db.CreateTable(&model.User{})
    db.CreateTable(&model.UserInfo{})
    // 关联添加数据： (因为关联关系在UserInfo表中，所以添加操作从UserInfo来入手)
    userinfo := demostruct.UserInfo{
        Pic:     "/upload/1.jpg",
        Address: "纽约市皇后区",
        Email:   "124234@126.com",
        User:    model.User{
            Age: 19,
            Name: "美国队长",
        },
    }
    db.Create(&userinfo)
}
```

### 8.4.2 级联查询

【1】Association方式查询：

```go
func main() {
    // 数据库连接省略...
    var userinfo demo.UserInfo
    // 如果只是执行下面这步操作，那么关联的User信息是查询不到的：
    db.First(&userinfo, "info_id = ?", 1)
    fmt.Println(userinfo)
    // 如果想要查询到User相关内容，必须执行如下操作：
    // Model参数：要查询的表数据，Association参数：关联到的具体的模型：模型名字User（字段名字）
    // Find参数：查询的数据要放在什么字段中&userinfo.User
    db.Model(&userinfo).Association("User").Find(&userinfo.User)
    fmt.Println(userinfo)
}
```







### 8.4.3 级联更新





### 8.4.4 级联删除











## 8.5 一对多操作

### 8.5.1 级联添加





### 8.5.2 级联查询







### 8.5.3 级联更新





### 8.5.4 级联删除







## 8.6 多对多操作

### 8.6.1 级联添加





### 8.6.2 级联查询







### 8.6.3 级联更新





### 8.6.4 级联删除





## 8.7 事务处理

















# 九. 常用方法







# 十. 支持原生SQL





# 十一. Gin整合GORM











































