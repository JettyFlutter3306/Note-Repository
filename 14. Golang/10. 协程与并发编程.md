# 协程与并发编程

# 一. 程序进程线程协程

【1】程序(program)

是为完成特定任务、用某种语言编写的一组指令的集合,是一段静态的代码。 （程序是静态的）

【2】进程(process)

是程序的一次执行过程。正在运行的一个程序，进程作为资源分配的单位，在内存中会为每个进程分配不同的内存区域。 （进程是动态的）是一个动的过程 ，进程的生命周期  :  有它自身的产生、存在和消亡的过程 

【3】线程(thread)

​	进程可进一步细化为线程， 是一个程序内部的一条执行路径。  若一个进程同一时间并行执行多个线程，就是支持多线程的。 	

【4】协程(goroutine)

又称为微线程，纤程，协程是一种用户态的轻量级线程

作用：在执行A函数的时候，可以随时中断，去执行B函数，然后中断继续执行A函数(可以自动切换)，注意这一切换过程并不是函数调用（没有调用语句)，过程很像多线程，然而协程中只有一个线程在执行（协程的本质是个单线程）

对于单线程下，我们不可避免程序中出现io操作，但如果我们能在自己的程序中(即用户程序级别，而非操作系统级别)控制单线程下的多个任务能在一个任务遇到io阻塞时就将寄存器上下文和栈保存到某个其他地方，然后切换到另外一个任务去计算。在任务切回来的时候，恢复先前保存的寄存器上下文和栈，这样就保证了该线程能够最大限度地处于就绪态，即随时都可以被cpu执行的状态，相当于我们在用户程序级别将自己的io操作最大限度地隐藏起来，从而可以迷惑操作系统，让其看到：该线程好像是一直在计算，io比较少，从而会更多的将cpu的执行权限分配给我们的线程（注意:线程是CPU控制的，而协程是程序自身控制的，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级)。



# 二. 协程入门

【1】案例：

请编写一个程序，完成如下功能:	

（1）在主线程中，开启一个goroutine，该goroutine每隔1秒输出"hello golang"  

（2）在主线程中也每隔一秒输出"hello golang"，输出10次后，退出程序 

（3）要求主线程和goroutine同时执行 

```go
func test() {
    for i := 1; i <= 10; i++ {
        fmt.Println("hello golang + " + strconv.Itoa(i))
        // 阻塞一秒：
        time.Sleep(time.Second)
    }
}

func main(){  // 主协程
    go test() // 开启一个协程
    for i := 1; i <= 10; i++ {
        fmt.Println("hello msb + " + strconv.Itoa(i))
        time.Sleep(time.Second)  // 阻塞一秒：
    }
}
```



# 三. 主死从随

【1】主死从随：

1) 如果主线程退出了，则协程即使还没有执行完毕，也会退出。

2) 当然协程也可以在主线程没有退出前，就自己结束了，比如完成了自己的任务。





# 四. 启动多个协程

【1】案例：

```go
func main() {
    // 匿名函数+外部变量 = 闭包
    for i := 1; i <= 5; i++ {
        // 启动一个协程
        // 使用匿名函数，直接调用匿名函数
        go func(n int) {
            fmt.Println(n)
        }(i)
    }
    time.Sleep(time.Second * 2)
}
```



# 五. WaitGroup

【1】WaitGroup的作用：

WaitGroup用于等待一组线程的结束。父线程调用Add方法来设定应等待的线程的数量。每个被等待的线程在结束时应调用Done方法。同时，主线程里可以调用Wait方法阻塞至所有线程结束。---》解决主线程在子协程结束后自动结束。

【2】主要方法：

（1）

```go
// Add方法向内部计数加上delta，delta可以是负数；
// 如果内部计数器变为0，Wait方法阻塞等待的所有线程都会释放，
// 如果计数器小于0，方法panic。注意Add加上正数的调用应在Wait之前，
// 否则Wait可能只会等待很少的线程。一般来说本方法应在创建新的线程或者其他应等待的事件之前调用。
func (wg *WaitGroup) Add(delta int)
```

（2）

```go
// Done方法减少WaitGroup计数器的值，应在线程的最后执行。
func (wg *WaitGroup) Done()
```

（3）

```go
// Wait方法阻塞直到WaitGroup计数器减为0。
func (wg *WaitGroup) Wait()
```

【3】案例：

（1）Add\Done\Wait：

```go
var wg sync.WaitGroup // 只定义无需赋值
func main() {
    // 启动五个协程
    for i := 1; i <= 5; i++ {
        wg.Add(1) // 协程开始的时候加1操作
        go func(n int){
            fmt.Println(n)
            wg.Done()  // 协程执行完成减1
        }(i)
    }
    // 主线程一直在阻塞，什么时候wg减为0了，就停止
    wg.Wait()
}
```

（2）如果防止忘记计数器减1操作，结合defer关键字使用：

```go
var wg sync.WaitGroup // 只定义无需赋值
func main(){
    // 启动五个协程
    for i := 1 ;i <= 5;i++ {
        wg.Add(1)  // 协程开始的时候加1操作
        go func(n int) {
            defer wg.Done()
            fmt.Println(n)		
        }(i)
    }
    // 主线程一直在阻塞，什么时候wg减为0了，就停止
    wg.Wait()
}
```

（3）可以最开始在知道协程次数的情况下先Add操作：

```go
var wg sync.WaitGroup  // 只定义无需赋值
func main() {
    wg.Add(5)
    // 启动五个协程
    for i := 1; i <= 5; i++ {
        go func(n int) {
            defer wg.Done()
            fmt.Println(n)		
        }(i)
    }
    // 主线程一直在阻塞，什么时候wg减为0了，就停止
    wg.Wait()
}
```

注意：Add中加入的数字和协程的次数一定要保持一致



# 六. 互斥锁

【1】案例：多个协程操纵同一数据  

```go
// 定义一个变量：
var totalNum int
var wg sync.WaitGroup  // 只定义无需赋值
func add() {
    defer wg.Done()
    for i := 0; i < 100000; i++{
        totalNum = totalNum + 1
    }
}
func sub() {
    defer wg.Done()
    for i := 0; i < 100000; i++{
        totalNum -= 1
    }
}
func main() {
    wg.Add(2)
    // 启动协程
    go add()
    go sub()
    wg.Wait()
    fmt.Println(totalNum)
}
```

结果：在理论上，这个totalNum结果应该是0 ，无论协程怎么交替执行，最终想象的结果就是0 

但是事实上：不是

解决问题：

有一个机制：确保：一个协程在执行逻辑的时候另外的协程不执行

⇨ 锁的机制 ⇨ 加入互斥锁

sync包提供了基本的同步基元，如互斥锁。除了Once和WaitGroup类型，大部分都是适用于低水平程序线程，高水平的同步使用channel通信更好一些。

本包的类型的值不应被拷贝。

```go
// Lock方法锁住m，如果m已经加锁，则阻塞直到m解锁。
func (m *Mutex) Lock()

// Unlock方法解锁m，如果m未加锁会导致运行时错误。锁和线程无关，
// 可以由不同的线程加锁和解锁。
func (m *Mutex) Unlock()
```

优化后：

```go
// 定义一个变量：
var totalNum int
var wg sync.WaitGroup  // 只定义无需赋值
// 加入互斥锁：
var lock sync.Mutex
func add() {
    defer wg.Done()
    for i := 0; i < 100000; i++ {
        // 加锁
        lock.Lock()
        totalNum = totalNum + 1
        // 解锁：
        lock.Unlock()
    }
}
func sub() {
    defer wg.Done()
    for i := 0; i < 100000; i++ {
        // 加锁
        lock.Lock()
        totalNum = totalNum - 1
        // 解锁：
        lock.Unlock()
    }
}
func main() {
    wg.Add(2)
    // 启动协程
    go add()
    go sub()
    wg.Wait()
    fmt.Println(totalNum)
}
```



# 七. 读写锁

golang 中 sync 包实现了两种锁 Mutex（互斥锁）和 RWMutex（读写锁）

【1】互斥锁 其中Mutex为互斥锁，Lock()加锁，Unlock()解锁，使用Lock()加锁后，便不能再次对其进行加锁，直到利用Unlock()解锁对其解锁后，才能再次加锁．适用于读写不确定场景，即读写次数没有明显的区别

----性能、效率相对来说比较低

【2】读写锁   RWMutex是一个读写锁，其经常用于读次数远远多于写次数的场景．  ---在读的时候，数据之间不产生影响，  写和读之间才会产生影响  

【3】案例： 

```go
var wg sync.WaitGroup // 只定义无需赋值
// 加入读写锁：
var lock sync.RWMutex

func read() {
    defer wg.Done()
    lock.RLock()  // 如果只是读数据，那么这个锁不产生影响，但是读写同时发生的时候，就会有影响
    fmt.Println("开始读取数据")
    time.Sleep(time.Second)
    fmt.Println("读取数据成功")
    lock.RUnlock()
}
func write() {
    defer wg.Done()
    lock.Lock()
    fmt.Println("开始修改数据")
    time.Sleep(time.Second * 10)
    fmt.Println("修改数据成功")
    lock.Unlock()
}
func main() {
    wg.Add(6)
    // 启动协程 ---> 场合：读多写少
    for i := 0; i < 5; i++ {
        go read()
    }
    go write()
    wg.Wait()
}
```



# 八. 管道

## 8.1 管道介绍

【1】管道（channel）特质介绍：		

（1）管道本质就是一个数据结构-队列 	 	

（2）数据是先进先出 	 	

（3）自身线程安全，多协程访问时，不需要加锁，channel本身就是线程安全的 	 	

（4）管道有类型的，一个string的管道只能存放string类型数据 	



## 8.2 快速入门

【1】管道的定义：

```go
var 变量名 chan 数据类型
```

1. chan管道关键字 

2. 数据类型指的是管道的类型，里面放入数据的类型，管道是有类型的，int类型的管道只能写入整数int 

3. 管道是引用类型，必须初始化才能写入数据，即make后才能使用 



【2】案例： 

```go
func main() {
    // 定义管道 、 声明管道 ---> 定义一个int类型的管道
    var intChan chan int
    // 通过make初始化：管道可以存放3个int类型的数据
    intChan = make(chan int, 3)
    // 证明管道是引用类型：
    fmt.Printf("intChan的值：%v", intChan) // 0xc000112080
    // 向管道存放数据：
    intChan<- 10
    num := 20
    intChan<- num
    intChan<- 40  
    // 注意：不能存放大于容量的数据：
    // intChan<- 80  
    // 在管道中读取数据：
    num1 := <-intChan
    num2 := <-intChan
    num3 := <-intChan
    fmt.Println(num1)
    fmt.Println(num2)
    fmt.Println(num3)
    // 注意：在没有使用协程的情况下，如果管道的数据已经全部取出，那么再取就会报错：
    num4 := <-intChan
    fmt.Println(num4)
    // 输出管道的长度：
    fmt.Printf("管道的实际长度：%v,管道的容量是：%v", len(intChan), cap(intChan))
}
```
