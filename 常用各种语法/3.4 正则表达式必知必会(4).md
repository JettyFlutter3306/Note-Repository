# 正则表达式(4)

# 一. 普通边界断言

## 1.1 简单示例

讲解定义前，先看一个示例，请匹配下文中的身高（不包括单位）：

```
曾小红，男、编号007，举重运动员，28岁，体重56KG，身高175cm。最好成绩：挺举98KG
```

`\d{3}`是不严谨的，它会把编号也匹配到结果中。修改正则为:`\d{3}cm` 可以精确得到结果，但同时把单位**cm**也包含进去了。这时就可以使用边界断言，**断言**数字后面是cm，正确的写法是：`\d{3}(?=cm)`，只会返回结果*175*. 所断言的cm不会包含进来。

上例如果要更严谨一点，也可以**往后**进行断言，如 `(?<=身高)\d{3}(?=cm)`，表示数字前面必须是“*身高*”，结果返回*175*。

匹配运动员的腰围数字(不包括单位)：

```
(?<=腰围)\d{3}(?=cm)
```

> 提醒项： `(?= )` 前置断言 `(?<= )` 后置断言

```
曾小红，男、编号007，举重运动员，28岁，体重56KG，身高175cm，腰围110cm。最好成绩：挺举98KG 
```

## 1.2 定义

边界断言指一段表达式**前后**是否满足指定**条件**，该条件由一个子表达式组成，基于前后字符能否匹配来计算布尔值。因断言部分不会消耗匹配字符，固又称为**零宽断言**。

边界断言包含以下四种语法：

| 语法                         | 描述                                     | 兼容性               |
| :--------------------------- | :--------------------------------------- | :------------------- |
| `(?= ...)` 前置断言          | 判定一段表达式**前面**是否满足条件       |                      |
| `(?! ...)` 前置**否定**断言  | 判定一段表达式**前面**是否**不满足**条件 |                      |
| `(?<= ...)` 后置断言         | 判定一段表达式**后面**是否满足条件       | js中部分浏览器不支持 |
| `(?<! ...)` 后置**否定**断言 | 判定一段表达式**后面**是否**不满足**条件 | js中部分浏览器不支持 |

> 所谓前置后置是以一段表达式为中心的前面与后面，而不是断言条件本身所处的前后位置。

## 1.3 前置断言

`(?= )` 即前置断言，表示一段表达式**前面**是否满足条件，如`\d{3}cm`表示3个数字后面必须是"cm"。

匹配文中所有体重数字(不包括单位和空格)：

小提示： `(?= )` 断言括号中可以是任意子表达式，注意区分单位的大小写。

```
\d{2}(?= (KG|kg))
```

```
姓名    编号   籍贯     体重    生日
于小彤 /  12 / 中国辽宁 / 63 KG / 1994-05-27
张惠妹 /  78 / 台湾台东县卑南乡 / 46 KG / 1972-08-09
沈佳妮 /  33 / 中国上海 / 51 kg / 1983-05-22
沈丹萍 /  34 / 中国南京 / 65 KG / 1960-02-19
王紫逸 /  3 / 中国香港 / 65 kg / 1986-12-15
```

`(?! )` 前置断言**否定式**，表示一段表达式前面**不能**匹配括号中子表达式。

## 1.4 后置断言

`(?<= )`后置断言，表示**边界**后置是否满足条件。如`(?<=验证码)\d{5}` 表示数字前三个字符必须"*验证码*"。

后置断言在javascript中只有**部分浏览器**支持。另外后置断言非常消耗性能，所以不推荐使用**无限大**的量词如：`*` `+` `{n,}`。甚至在JAVA、Python、PHP会直接报**语法错误**。举例 `(?<=.+)aa` 就是是错误的，必须改成一个有限范围如： `(?<=.{1,200})aa`。

前后置断言在解析html有奇效，比如爬取一张网页以后解析所有`<a href=""></a>`中的链接，来一起实现它。

匹配所有**a**标签中链接(不包括标签名)：

```
(?<=<a.{1,100}href=\").*?(?=\")
```

小提示：

- `?`最少化匹配
- `(?=)`前置断言
- `(?<=)`后置断言

示例：https://www.taobao.com/

```html
<html lang="en">
<head>
  <script src="https://cdn.bootcdn.net/highlight.min.js"></script>
  <link href="https://cdn.bootcdn.net/default.min.css" rel="stylesheet">
</head>
<body>
  <div id="app"></div>
  <a href="/save" > 保存</a> 友情链接<a href="https://www.baidu.com">baidu </a>
  <a   id="a1" href="https://www.github.com?id=f%22"  >github </a>  
  <a id="aa" href="https://www.taobao.com/">taobao </a>
</body>
</html>
```

> 为方便记忆，你可以看到其`<`指向后面就是后置断言。
>

`(?<！)`后置断言**否定式**，表示一段表达式后面**不能**匹配括号中子表达式。

# 二. 高级特性

前面所学案例只是边界断言普通特性，事实上它的强大远不止如此，它还可以包含如下特性：

1. **零宽断言**：断言条件本身不会消耗字符
2. **多边界断言:**一个正则可同时存在多个边界断言。根据其所处位置来决定断言的边界。
3. **条件组合**:多个子断言可以进行布尔运算如：`&&` `||` `()`，
4. **任意边界**：可以是任意合法的表达式边界，甚至可以是**空**字符边界。

## 2.1 零宽断言

零宽断言指条件本身不会消耗字符，在一些特殊场景中这很有用，比如要匹配下文中被@的昵称：

```
@鲁班大叔@鱼皮@水哥 hello up主们
```

如果使用`@.+?[@ ]`匹配结果是==@鲁班大叔@==鱼皮==@水哥== hello up主们*，中间的“*鱼皮*”没有被匹配，因为“*鲁班大叔”后的**@**被消耗了，而这是和“鱼皮”共享的**@**。

正确的写法是`@.+?(?=@|\s)` ，使用**@**断言结尾之后。

匹配文中所有被@的昵称（包括**@**符号）：

```
@.+?(?=@|\s)
```

小提示：

- `?`最少化匹配
- `(?=)`前置断言

示例：@鱼皮

```
@鲁班大叔@鱼皮 @程序羊 @水哥 hello up 主们
```

> 有时零宽断言也会带来一些困扰，比如匹配短句“*hello up*” 如果使用`(?<= )hello(?= )up` 是无法匹的。因为中间空格没有被包含进去，所以要加入进去。所以切记，条件只是条件不会消耗字符。

## 2.2 多边界断言

一个正则可同时存在**多个**边界断言，根据其所处位置来决定断言的边界，如:`hello(?= ) up(?= )`,第一个断言以hello 作为边界，第二个断言以 up 作为边界。

## 2.3 条件组合

边界条件本质上就是**布尔值计算**，其自然可以进行类似`&&` `||` `()`布尔运算，以应对更复杂的场景。其书写方式有以几种：

1. `h(?=条件1)(?=条件2)` `且`运算,指必须同时满足多个条件
2. `h(?=(?=条件1)(?=条件2))` `且`运算,条件1与条件2组成一个新条件,并且两个条件都必须满足
3. `h(?=(?=条件1)|(?!条件2))` `或`运算,满足条件1或者 **不满足** 条件2
4. `h(?=表达式1|(?=条件1)(?!条件2))` `混合`运算,表示满足表达式1或者同时满足条件1、2

上述条件组合在**后置断言**中同样适用，而且没有额外的兼容性问题。另外上述任意条件都是基于**同一个边界**进行计算，即字符h。

有了条件组合这个利器，我们编写正则能力将会上一个新台阶，以前无法实现的，现在都可以实现了。比如实现一个css语法错误检查器。我们试着来编写一个正则用于找出错误的**颜色**代码。其语法如下：

1. 以**`#`**开头，以`;`结尾
2. 必须是 16 进制数值，**数字**或字母 **a-f**
3. 数值长度必须是**6位**或者**3位**
4. 示例：`#53e;` `#55432c;`

找出**错误**的颜色代码实现思路如下：

1. 写出正确的匹配正则：`#[\da-f]{6}|[\da-f]{3};`
2. 基于前置**否定断言**判断 **#** 后是否 **不满足** 条件：`#(?![\da-f]{6};|[\da-f]{3};)`
3. 然后把错误的字符加上：`#(?![\da-f]{6};|[\da-f]{3};).{0,7}`

匹配文中错误的颜色代码：

```
#(?![\da-f]{6};|[\da-f]{3};).*
```

- \1. 以**#**开头，以**;**结尾
- \2. 必须是16进制数值，**数字** 或字母**a-f**
- \3. 数值长度必须是**6位**或者**3位**

示例：#112H3;

```css
html {   
    color: #e1e1e;
    background-color: #1e1e1e;
}
body {
    color: #55432c;
    background-color: #53e; 
}
div {
    color: #55h32c;
}
```

## 2.4 任意边界

边界断言另一个特性，其针对的边界可以是任意表达式，甚至可以是**空字符**边界。这一点又赋予正则处理复杂场景的能力。比如检测用户密码是否符合以下要求：

1. 密码长度是8-20位
2. 大小写字母以及数字必须都有一个。

先尝使用用常规正则进行匹配如：`.*[A-Z].*[a-z].*\d`，仔细推断一下就知道这不行，因为不知道大小写字母或数字出现的**位置**以及**顺序**，而且也无法确定其数量范围。

实现上述需就可以采用**分而治之**的思路，把每个条件分别进行计算：

1. 验证长度：`(?=^.{8,20}$)`,表示总字符长度在8至20之间。`^` `$` 是两个特殊字符，这里分别表示文本的开头与结尾，将在后续章节专门学习。
2. 验证大写字母：`(?=.*[A-Z])`，表示文中任意地方至少出现一次**大写**字母。
3. 验证小写字母：`(?=.*[a-z])`，表示文中任意地方至少出现一次**小写**字母。
4. 验证数字：`(?=.*\d)`，表示文中任意地方至少出现一次**数字**。
5. 最后组合条件并追加内容 `(?=^.{8,20}$)(?=.*[A-Z])(?=.*[a-z])(?=.*[\d]).+`

请注意所有的条件写在正则的最开头，是以**空字符**作为边界的，或者说以文本开头作为边界，计算文中内容是否满足每个条件。由于各个条件都是独立的匹配整个文本，所以调换顺序也不会影响匹配结果。

找出所有符合条件的密码：

```
(?=^.{8,20}$)(?=.*[a-z])(?=.*[A-Z])(?=.*[\d]).+
```

1. 密码长度是8-20位
2. 大小写字母以及数字必须都有一个。

# 三. 常见案例

## 3.1 变量名称提取

接下来是过关练习，提取js代码中所有所有合法变量名，如`var abc="";` 只是变量名**abc**,不包括赋予的值部分。这用来实现语法检测器非常有用，开始挑战吧。

查找JS代码中的合法变量名：

```
(?<=(var|let|const)\s+)[A-z_]\w*?(?=[ =;])
```

示例：`var abc = ""`;
js变量名规范：

- 通过`var|let|const` 声明变量
- 变量以**字母**或**下划线**开头
- 变量名只能是字母、数字、下划线

```js
// 初始化
const   fs = require('fs')
const path = require('path')
// 1.读取数据
fs.readFile(path.join(__dirname, 'data.json'), 'utf8', function (err, data) {
    if (err) {
        var d;
        console.log(err);
        return
    } 
    // 2.增加数据 修改数据
    let 0str = JSON.parse(data)
    let _array= str.nodes;
    for (let k=1000,index = k; index < k+50; index++) {
        const element = array[index];
        console.log(element.label+" / "+element.info);
    }
});
```