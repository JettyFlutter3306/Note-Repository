# NO.160相交链表

==简单==

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

图示两个链表在节点 c1 开始相交：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 
(A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，
而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)

```
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

# 方法1：哈希表

判断两个链表是否相交，可以使用哈希集合存储链表节点。

首先遍历链表 $\textit{headA}$，并将链表 $\textit{headA}$ 中的每个节点加入哈希集合中。然后遍历链表 $\textit{headB}$，对于遍历到的每个节点，判断该节点是否在哈希集合中：

如果当前节点不在哈希集合中，则继续遍历下一个节点；

如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 $\textit{headB}$ 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。

如果链表 $\textit{headB}$ 中的所有节点都不在哈希集合中，则两个链表不相交，返回 $\text{null}$。

**Java**：

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    Set<ListNode> set = new HashSet<ListNode>() {{
        for (ListNode p = headA; p != null; p = p.next) {
            add(p);
        }
    }};
    for (ListNode p = headB; p != null; p = p.next) {
        if (set.contains(p)) {
            return p;
        }
    }
    return null;
}
```

**Go**：

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    
}
```

**复杂度分析**

- **时间复杂度**：$O(m+n)$，其中 $m$ 和 $n$ 是分别是链表 $\textit{headA}$ 和 $\textit{headB}$ 的长度。需要遍历两个链表各一次。

- **空间复杂度**：$O(m)$，其中 $m$ 是链表 $\textit{headA}$ 的长度。需要使用哈希集合存储链表 $\textit{headA}$ 中的全部节点。

# 方法2：双指针

**思路和算法**

使用双指针的方法，可以将空间复杂度降至 $O(1)$。

只有当链表 $\textit{headA}$ 和 $\textit{headB}$ 都不为空时，两个链表才可能相交。因此首先判断链表 $\textit{headA}$ 和 $\textit{headB}$ 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 $\text{null}$。

当链表 $\textit{headA}$ 和 $\textit{headB}$ 都不为空时，创建两个指针 $\textit{pA}$ 和 $\textit{pB}$，初始时分别指向两个链表的头节点 $\textit{headA}$ 和 $\textit{headB}$，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：

每步操作需要同时更新指针 $\textit{pA}$ 和 $\textit{pB}$。

如果指针 $\textit{pA}$ 不为空，则将指针 $\textit{pA}$ 移到下一个节点；如果指针 $\textit{pB}$ 不为空，则将指针 $\textit{pB}$ 移到下一个节点。

如果指针 $\textit{pA}$ 为空，则将指针 $\textit{pA}$ 移到链表 $\textit{headB}$ 的头节点；如果指针 $\textit{pB}$pB 为空，则将指针 $\textit{pB}$ 移到链表 $\textit{headA}$ 的头节点。

当指针 $\textit{pA}$pA 和 $\textit{pB}$ 指向同一个节点或者都为空时，返回它们指向的节点或者 $\text{null}$。

**证明**

下面提供双指针方法的正确性证明。考虑两种情况，第一种情况是两个链表相交，第二种情况是两个链表不相交。

**情况一：两个链表相交**

链表 $\textit{headA}$ 和 $\textit{headB}$ 的长度分别是 $m$ 和 $n$。假设链表 $\textit{headA}$ 的不相交部分有 $a$ 个节点，链表 $\textit{headB}$ 的不相交部分有 $b$ 个节点，两个链表相交的部分有 $c$ 个节点，则有 $a+c=m$，$b+c=n$。

如果 $a=b$，则两个指针会同时到达两个链表相交的节点，此时返回相交的节点；

如果 $a \ne b$，则指针 $\textit{pA}$ 会遍历完链表 $\textit{headA}$，指针 $\textit{pB}$ 会遍历完链表 $\textit{headB}$，两个指针不会同时到达链表的尾节点，然后指针 $\textit{pA}$pA 移到链表 $\textit{headB}$ 的头节点，指针 $\textit{pB}$ 移到链表 $\textit{headA}$ 的头节点，然后两个指针继续移动，在指针 $\textit{pA}$ 移动了 $a+c+b$ 次、指针 $\textit{pB}$ 移动了 $b+c+a$ 次之后，两个指针会同时到达两个链表相交的节点，该节点也是两个指针第一次同时指向的节点，此时返回相交的节点。

**情况二：两个链表不相交**

链表 $\textit{headA}$ 和 $\textit{headB}$ 的长度分别是 $m$ 和 $n$。考虑当 $m=n$ 和 $m \ne n$ 时，两个指针分别会如何移动：

如果 $m=n$，则两个指针会同时到达两个链表的尾节点，然后同时变成空值 $\text{null}$l，此时返回 $\text{null}$；

如果 $m \ne n$，则由于两个链表没有公共节点，两个指针也不会同时到达两个链表的尾节点，因此两个指针都会遍历完两个链表，在指针 $\textit{pA}$ 移动了 $m+n$ 次、指针 $\textit{pB}$ 移动了 $n+m$ 次之后，两个指针会同时变成空值 $\text{null}$，此时返回 $\text{null}$。

**Java**：

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    ListNode p1 = headA, p2 = headB;
    while (p1 != p2) {
        p1 = p1 == null ? headB : p1.next;
        p2 = p2 == null ? headA : p2.next;
    }
    return p1;
}
```

**Go**：

```go

```