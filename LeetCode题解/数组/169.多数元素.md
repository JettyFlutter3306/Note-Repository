# NO.169 多数元素

给定一个大小为 $n$ 的数组 $nums$ ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 $⌊ n/2 ⌋$ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**

```
输入：nums = [2,2,1,1,1,2,2]
输出：2
```

# 方法1：哈希表

最简单的暴力方法是，枚举数组中的每个元素，再遍历一遍数组统计其出现次数。该方法的时间复杂度是 $O(n^2)$

我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。

我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，返回值最大的键。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。

**Java**：

```java
public int majorityElement(int[] nums) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int num : nums) {
        map.compute(num, (k, v) -> v == null ? 1 : ++v);
    }

    Map.Entry<Integer, Integer> majorityEntry = null;
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        if (majorityEntry == null || entry.getValue() > majorityEntry.getValue()) {
            majorityEntry = entry;
        }
    }

    return majorityEntry.getKey();
}
```

**Go**：

```go
```

**复杂度分析**

- 时间复杂度：$O(n)$​
- 其中 $n$ 是数组 $nums$ 的长度。我们遍历数组 $nums$ 一次，对于 $nums$ 中的每一个元素，将其插入哈希表都只需要常数时间。如果在遍历时没有维护最大值，在遍历结束后还需要对哈希表进行遍历，因为哈希表中占用的空间为 $O(n)$（可参考下文的空间复杂度分析），那么遍历的时间不会超过 $O(n)$。因此总时间复杂度为 $O(n)$。

- 空间复杂度：$O(n)$​
- 哈希表最多包含 $n - \lfloor \dfrac{n}{2} \rfloor$ 个键值对，所以占用的空间为 $O(n)$。这是因为任意一个长度为 nn 的数组最多只能包含 $n$ 个不同的值，但题中保证 $nums$ 一定有一个众数，会占用（最少） $\lfloor \dfrac{n}{2} \rfloor + 1$ 个数字。因此最多有 $n - (\lfloor \dfrac{n}{2} \rfloor + 1)$个不同的其他数字，所以最多有 n $- \lfloor \dfrac{n}{2} \rfloor$个不同的元素。

# 方法2：排序

**思路**

如果将数组 $nums$ 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 $\lfloor \dfrac{n}{2} \rfloor$的元素（下标从 0 开始）一定是众数。

**算法**

对于这种算法，我们先将 $nums$ 数组排序，然后返回上文所说的下标对应的元素。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 $n$ 为奇数的情况，第二个例子是 $n$ 为偶数的情况。

![image.png](https://pic.leetcode-cn.com/a70cb9316157ecd7eeffe7900d3ca83849079824964e8a0aaefbcffd4040f175-image.png)

对于每种情况，数组下面的线表示如果众数是数组中的最小值时覆盖的下标，数组下面的线表示如果众数是数组中的最大值时覆盖的下标。对于其他的情况，这条线会在这两种极端情况的中间。对于这两种极端情况，它们会在下标为 $\lfloor \dfrac{n}{2} \rfloor$的地方有重叠。因此，无论众数是多少，返回 $\lfloor \dfrac{n}{2} \rfloor$ 下标对应的值都是正确的。

**Java**：

```java
public int majorityElement(int[] nums) {
    Arrays.sort(nums);
    return nums[nums.length / 2];
}
```

**Go**：

```go

```