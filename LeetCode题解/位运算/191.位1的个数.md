# NO.191 位1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/汉明重量)）。

**示例 1：**

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

**示例 2：**

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

**示例 3：**

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

# 方法一：循环检查二进制位

**思路及解法**

我们可以直接循环检查给定整数 $n$ 的二进制位的每一位是否为 $1$。

具体代码中，当检查第 $i$ 位时，我们可以让 $n$ 与 $2^i$。进行与运算，当且仅当 $n$ 的第 $i$ 位为 $1$ 时，运算结果不为 $0$。

**Java**：

```java
public int hammingWeight(int n) {
    int ans = 0;
    while (n != 0) {
        if ((n & 1) == 1) {
            ans++;
        }
        n >>>= 1;
    }
    return ans;
}
```

**Go**：

```go

```

**复杂度分析**

- **时间复杂度**：$O(k)$，其中 $k$ 是 $\text{int}$ 型的二进制位数，$k=32$。我们需要检查 $n$ 的二进制位的每一位，一共需要检查 $32$ 位。

- **空间复杂度**：$O(1)$，我们只需要常数的空间保存若干变量。

# 方法二：位运算优化

**思路及解法**

观察这个运算：$n~\&~(n - 1)$，其运算结果恰为把 $n$ 的二进制位中的最低位的 $1$ 变为 $0$ 之后的结果。

如：$6~\&~(6-1) = 4$, $6 = (110)_2$, $4 = (100)_2$ ，运算结果 $4$ 即为把 $6$ 的二进制位中的最低位的 $1$ 变为 $0$ 之后的结果。

这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 $n$ 与 $n - 1$ 做与运算，直到 $n$ 变为 $0$ 即可。因为每次运算会使得 $n$ 的最低位的 $1$ 被翻转，因此运算次数就等于 $n$ 的二进制位中 $1$ 的个数。

**Java**：

```java
public int hammingWeight(int n) {
    int ret = 0;
    while (n != 0) {
        n &= n - 1;
        ret++;
    }
    return ret;
}
```

**Go**：

```go
```

**复杂度分析**：

- 时间复杂度：$O(\log n)$。循环次数等于 $n$ 的二进制位中 $1$ 的个数，最坏情况下 $n$ 的二进制位全部为 $1$。我们需要循环 $\log n$ 次。


- 空间复杂度：$O(1)$，我们只需要常数的空间保存若干变量。
